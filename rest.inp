#{if step>=55
#{ifdef TESTROM
: foo 12345 ; foo 
latest @ @ latest ! 
3ret 
#}ifdef
#}if
#{if step>=56
: [ 10 parse 2drop ; immediate [ comments should start working from here on out
#{ifdef TESTROM
: foo		[	// verify that comments work within definitions as well
	4321	[ 4321
; foo 		[	// and invoke foo for later verification
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret			[ // and switch back to test from within the outer repl
#}ifdef
#}if
#{if step>=57
[ // Reserve a zero-filled patch'able byte/cell for storing a branch offset
: offset
	0	[ 0
	offset,	[ \ 0
	here	[ here
	@	[ h
;
[ // if{ is just syntax sugar replacement for the traditional Forth IF keyword
: if{
	lit	[	// lit escapes the following byte(s)
	jz	[ jz	// escaped by lit
#{if offset==1
	lit	[ jz	// padding used for 1 byte offset, escaped by lit
#}if
	offset,	[ \ jz
	offset	[ h \ 0
;
immediate
[ // patch is used to back patch the offset which was generated by "offset"
: patch		[ o h
	over	[ o h o
	-	[ o n:h-o
	swap	[ n o
	dec	[ n a:o-1
#{if THREAD==1
	c!	[ (a:n)
#}if
#{if THREAD==2
	dec	[ n a:a-1
	!	[ (a:n)
#}if
;
[ // }if is just syntax sugar replacement for traditional Forth's THEN
[ // it patches up the reserved offset saved on the stack at the start
: }if		[ o
	here	[ o here
	@	[ o h
	patch
;
immediate
[ test if{ ... }if using a simple definition:
[ ?dup : dup's the tos only if it is non-zero
: ?dup			[ n
	dup		[ n n
	if{		[ n	// n != 0
		dup	[ n n
	}if		[ n n?	// not dup'ed if n==0
;
#{ifdef TESTROM
0	[ 0
?dup	[ 0
1	[ 0 1
?dup	[ 0 1 1
3ret
#}ifdef
#}if
#{if step>=58
[ "jump" compiles in the "j" operator and the placeholder for the offset
: jump
	lit	[	// lit escapes the following byte(s)
	j	[ j	// escaped by lit
#{if offset==1
	lit	[ j	// padding used for 1 byte offset, escaped by lit
#}if
	offset,	[ \ j
	offset	[ h \ 0
;
[ compile the "immediate" word following it by setting the override flag
: [compile]
	override!
;
immediate

[	// this is just a few dummy {{{ to balance out the unbalanced braces

[ }else{ can be treated as an unconditional branch followed by }if
: }else{		[ o
	jump		[ o h	// compile the unconditional branch
	swap		[ h o
	[compile] }if	[ h	// to compile an }if despite its immediacy
;
immediate
#{ifdef TESTROM
: foo			[ n
	if{		[	// n!=0
		1	[ 1
	}else{		[	// n==0
		0	[ 0
	}if		[ 0,n==0;1,n!=0
;
0			[ 0
foo			[ 0
10			[ 0 1
foo			[ 0 1
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if
#{if step>=59
[ // The loop control structures are:
[ // loop{ ... }while{ ... }loop and loop{ ... }until{ ... }loop

[ // loop{ just needs to leave a pointer to refer back to the start of the loop
: loop{
	here	[ here (here:h)
	@	[ h
;
immediate
[	// this is just a few dummy }}{ to balance out the unbalanced braces
[ // An obvious way to think of }while{ is that it is just an if{ within a loop
: }while{
	[compile] if{	[ l	// to compile an if{ despite its immediacy
;
immediate
[	// this is just a few dummy }}}{{ to balance out the unbalanced braces
[ // And a }loop is just an }else{ within a loop, but with a backward jump
: }loop				[ h l
	[compile] }else{	[ h l	// compile an }else{ despite immediacy
	swap			[ l h
	patch			[	// back patch with a -ve offset
;
[	// this is just a few dummy } to balance out the unbalanced braces
immediate
#{ifdef TESTROM
: fib			[ i:n
	1		[ i a:1
	0		[ i a b:0
	loop{		[ i a b		// a>b
		over	[ i a b a
		+	[ i a c:b+a
		swap	[ i c a
		third	[ i c a i
	}while{		[ i c a		// i!=0
		rot	[ c a i
		dec	[ c a i:i-1
		rot	[ a i c
		rot	[ i c a
	}loop		[ i c a		// i==0
	drop		[ i c
	nip		[ c		// c=fibonacci(n), n>=1
;
10			[ 10	// +2
fib			[ 144	// fibonacci(10+2)
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if
#{if step>=60
[	// this is just a few dummy { to balance out the unbalanced braces
[ // }until{ is just like }while{ except the jump condition is reversed
: }until{
	lit	[	// lit escapes the following byte(s)
	jnz	[ jnz	// escaped by lit
#{if offset==1
	lit	[ jnz	// padding used for 1 byte offset, escaped by lit
#}if
	offset,	[ \ jnz
	offset	[ h \ 0
;
immediate
: ==		[ a b
	-	[ a-b
	0=	[ a==b
;
[	// this is just a few dummy } to balance out the unbalanced braces
#{ifdef TESTROM
: sum			[ n
	0		[ n a:0
	0		[ n a i:0
	loop{		[ n a i
		third	[ n a i n
		over	[ n a i n i
		==	[ n a i n==i
	}until{		[ n a i		// n!=i
		tuck	[ n i a i
		+	[ n i a:a+i
		swap	[ n a i
		inc	[ n a i:i+1
	}loop		[ n a i		// n==i
	drop		[ n a
	nip		[ a
;
10			[ 10
sum			[ 45=10*9/2
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if
#{if step>=61
: compile	[	| w ]
	r>	[ w	|   ] // get the next exec'utable address
	dup	[ w w	|   ]
#{if THREAD==1
	c@	[ w o
#}if
#{if THREAD==2
	@	[ w o
#}if
	swap	[ o w
	inc	[ o w+1
#{if THREAD==2
	inc	[ o w+2		// XXX: any problems with assuming cell=2 here?
#}if
	>r	[ o	| w+d ]
#{if THREAD==1
	c,	[	| w+d ] \ o
#}if
#{if THREAD==2
	,	[	| w+d ] \ o
#}if
;
[ A definition of for{ ... }for loops in terms of regular while loops
: for{				[ i:index n:limit	// for loop over [i:n)
	[compile] loop{		[ i n			\ loop{
	compile over		[ i n i			\	over
	compile over		[ i n i n		\	over
	compile >r		[ i n i		|   n ] \	>r
	compile >r		[ i n 		| i n ] \	>r
	compile -		[ i-n		| i n ] \	-
	[compile] }while{	[		| i n ] \ }while{	// i!=n
;
immediate
: }for				[		| i n ]
	compile r>		[ i		|   n ] \	r>
	compile inc		[ i:i+1		|   n ] \	inc
	compile r>		[ i n		|     ] \	r>
	[compile] }loop		[ 		| i n ] \ }loop		// i==n
	compile r>		[ i		|   n ]	\ r>
	compile drop		[		|   n ] \ drop
	compile r>		[ n		|     ] \ r>
	compile drop		[		|     ] \ drop
;
immediate
#{ifdef TESTROM
: sum			[ n
	0		[ n a:0
	swap		[ a n
	0		[ a n i:0
	swap		[ a i n
	for{		[ a	| i n ]
		i	[ a i	| i n ]
		+	[ a:a+i	| i n ]
	}for		[ a
;
10			[ 10
sum			[ 45
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if

#{if step>=55
#{ifdef TESTROM
: foo 12345 ; foo 
latest @ @ latest ! 
3ret 
#}ifdef
#}if
#{if step>=56
: [ 10 parse 2drop ; immediate [ comments should start working from here on out
#{ifdef TESTROM
: foo		[	// verify that comments work within definitions as well
	4321	[ 4321
; foo 		[	// and invoke foo for later verification
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret			[ // and switch back to test from within the outer repl
#}ifdef
#}if
#{if step>=57
[ // Reserve a zero-filled patch'able byte/cell for storing a branch offset
: offset
	0	[ 0
	offset,	[ \ 0
	here	[ here
	@	[ h
;
[ // if{ is just syntax sugar replacement for the traditional Forth IF keyword
: if{
#{if THREAD!=3
#{if prim_var_deref==1
[ THREAD==1 and prim_var_deref==1 => x86-user
[ THREAD==4 and prim_var_deref==1 => msp430-stc
[ THREAD==5 and prim_var_deref==1 => msp430-fcode
	#jz	[ jz	// for rationale, see the comments where #jz is defined
#}if
#{if prim_var_deref!=1
	lit	[	// lit escapes the following byte(s)
	jz	[ jz	// escaped by lit
#{if offset==1
	lit	[ jz	// padding escaped by lit
#}if
#{if offset==3
	pad0 pad0 pad0	[ jz	// padding escaped by lit
#}if
#{if offset==7
	pad0 pad0 pad0 pad0 pad0 pad0 pad0	[ jz // padding escaped by lit
#}if
#}if
#}if

#{if THREAD==3
	#jz	[ jz	// since thread type3 cannot use the above trick
#}if
#{if THREAD!=4
	offset,	[ \ jz
	offset	[ h \ 0
#}if
#{if THREAD==4

#{if ARCH eq "msp430"
[ // machine code for the "conditional jump if zero" looks like this:
[ //	0c11e: 27 83                     DECD    R7
[ //	0c120: 06 f6                     AND     R6,     R6
[ //	0c122: 26 47                     MOV     @R7,    R6
[ //	0c124: 0b 24                     JZ      0xc13c
[ // Since jz_cfa has the code for the preamble, just generate a call to it
[ // and then reserve 2 bytes for the actual jump itself to be "patch"ed later
	compdef [ \ call jz_cfa	// appended to the dictionary to call preamble
	9216	[ 0x2400	// MSP 430 uses 2 bytes for a conditional jump
	,	[ \ 0 0x24	// 6 bits opcode for JZ + 10 bits jump offset
	here	[ here		// the 10 bit jump offset is zero filled
	@	[ h		// and will be "patch"ed later
#}if

#{if ARCH eq "z80"
[ // machine code for the "conditional jump if zero" looks like this:
[ //	001009 7B               [ 4] 2683  ld a, e
[ //	00100A B2               [ 4] 2684  or a, d
[ //	00100B CD 3C 00         [17] 2685  CALL realdrop
[ //	00100E 28                    2686  .db 0x28
[ //	00100F 0B                    2688  .db lbl031_then-.-1
[ // Since jz_cfa contains the first 6 bytes that are needed, copy them as is
[ // and then reserve 1 byte for the actual jump offset to be "patch"ed later
	dup	[ jz_cfa jz_cfa (jz_cfa:0xB27B)
	@	[ jz_cfa 0xB27B
	,	[ jz_cfa \ 0x7B 0xB2
	2 +	[ j2:jz_cfa+2
	dup	[ j2 j2 (j2:0x3CCD)
	@	[ j2 0x3CCD
	,	[ j2 \ 0xCD 0x3C
	2 +	[ j4:j2+2 (j4:0x2800)
	@	[ 0x2800
	,	[ \ 0x00 0x28
	0 c,	[ \ 0		// reserved for the offset
	here	[ here
	@	[ h
#}if

#}if
;
immediate

#{if THREAD==3
#{if PRIMSZ==2

[ Store s, a little-endian short at address a such that a[0,1]==(lo(s),hi(s))
[ s! is needed by the C port where the jump offset is a short (uses 16 bits)
[ since c! works only on bytes and ! works only on int (ie 32 bit) sized values
: s!		[ s a
	2dup	[ s a s a
	c!	[ s a (a:s)
	inc	[ s h:a+1
	swap	[ h s
	8	[ h s 8
	>>	[ h t:s>>8
	swap	[ t h
	c!	[ (h:t)
;

#}if
#}if

[ // patch is used to back patch the offset which was generated by "offset"
: patch		[ o h
	over	[ o h o
	-	[ o n:h-o
#{if THREAD==3
#{if PRIMSZ==2
	1	[ o n 1		// for thread type3, the offset needs to be
	>>	[ o n:n>>1	// divided by 2 since C does a pointer addition
#}if
#}if
#{if THREAD==4
#{if ARCH eq "msp430"
	1	[ o n 1		// for MSP430 the offset needs to be divided by
	>>	[ o n:n>>1	// 2 since the jump ops use word size offsets
#}if
#}if
	swap	[ n o
	dec	[ n a:o-1
#{if THREAD==1
	c!	[ (a:n)
#}if
#{if THREAD==2
	dec	[ n a:a-1
	!	[ (a:n)
#}if
#{if THREAD==3
#{if PRIMSZ==1
	c!	[ (a:n)
#}if
#{if PRIMSZ==2
	dec	[ n a:a-1
	s!	[ (a:n)
#}if
#}if
#{if THREAD==4

#{if ARCH eq "msp430"
[ // machine code for the "conditional jump if zero" looks like this
[ //	0c124: 0b 24                     JZ      0xc13c
	dec	[ n a:a-1
	swap	[ a n
	1023	[ a n 0x3ff	// mask for the lower 10 bits for jump offset
	&	[ a o:n&0x3ff	// to clear off top 6 bits to place the opcode
	over	[ a o a		// then use the address passed in from the 'if'
	@	[ a o op	// to retrieve the opcode that was saved in the
	|	[ a op:o|op	// previous jump location and merge it in
	swap	[ op a		// and then
	!	[ (a:op)	// store it back
#}if

#{if ARCH eq "z80"
	c!	[ (a:n)
#}if

#}if

#{if THREAD==5
	c!	[ (a:n)
#}if

#{if THREAD>5
	70 emit	[ add a catchall for newer THREAD'ing types (70=='F' for fail)
#}if

;

[ // }if is just syntax sugar replacement for traditional Forth's THEN
[ // it patches up the reserved offset saved on the stack at the start
: }if		[ o
	here	[ o here
	@	[ o h
	patch
;
immediate
[ test if{ ... }if using a simple definition:
[ ?dup : dup's the tos only if it is non-zero
: ?dup			[ n
	dup		[ n n
	if{		[ n	// n != 0
		dup	[ n n
	}if		[ n n?	// not dup'ed if n==0
;
#{ifdef TESTROM
0	[ 0
?dup	[ 0
1	[ 0 1
?dup	[ 0 1 1
3ret
#}ifdef
#}if

#{if step>=58
[ "jump" compiles in the "j" operator and the placeholder for the offset
[ for "subroutine threaded code"/STC, it compiles in the machine code for "jmp"
: jump
#{if THREAD!=3
#{if prim_var_deref==1
[ THREAD==1 and prim_var_deref==1 => x86-user
[ THREAD==4 and prim_var_deref==1 => msp430-stc
[ THREAD==5 and prim_var_deref==1 => msp430-fcode
	#j	[ j	// for rationale, see the comments where #j is defined
#}if
#{if prim_var_deref!=1
	lit	[	// lit escapes the following byte(s)
	j	[ j	// escaped by lit
#{if offset==1
	lit	[ j	// padding used for 1 byte offset, escaped by lit
#}if
#{if offset==3
	pad0 pad0 pad0	[ j	// padding escaped by lit
#}if
#{if offset==7
	pad0 pad0 pad0 pad0 pad0 pad0 pad0	[ j // padding escaped by lit
#}if
#}if
#}if

#{if THREAD==3
	#j	[ j	// since thread type3 cannot use the above trick
#}if
#{if THREAD!=4
	offset,	[ \ j
	offset	[ h \ 0
#}if
#{if THREAD==4

#{if ARCH eq "msp430"
[ // machine code for the "unconditional jump" looks like this:
[ //	0c0e8: 0b 3c                     JMP     0xc100
	drop	[		// since j_cfa does not contain anything useful
	15360	[ 0x3c00	// jmp opcode is 0b001111 + 10 addl offset bits
	,	[ \ 0 0x3c	// stick that unconditional jump into the
	here	[ here		// dictionary and then leave the current offset
	@	[ h		// to be "patch"ed up later
#}if

#{if ARCH eq "z80"
[ // machine code for the "long unconditional jump" looks like this:
[ //	0006FA C3 D8 06         [10] 1183  JP lbl120_begin
[ // There is also the "short unconditional jump" which looks like this:
[ //	0006F8 18 03            [12] 1182  JR lbl120_endloop
[ // for now I'll choose the short jump and switch if it runs into trouble
		[ j_cfa
	@	[ 0xC918 (j_cfa:0xC918)	// the 0xc9 happens to be a ret
	,	[ \ 0x18 0xC9		// so we just use that as the filler
	here	[ here			// which will be "patch"ed up ...
	@	[ h			// ... later
#}if

#}if
;

[ compile the "immediate" word following it by setting the override flag
: [compile]
	override!
;
immediate

[	// this is just a few dummy {{{ to balance out the unbalanced braces

[ }else{ can be treated as an unconditional branch followed by }if
: }else{		[ o
	jump		[ o h	// compile the unconditional branch
	swap		[ h o
	[compile] }if	[ h	// to compile an }if despite its immediacy
;
immediate

#{ifdef TESTROM
: foo			[ n
	if{		[	// n!=0
		1	[ 1
	}else{		[	// n==0
		0	[ 0
	}if		[ 0,n==0;1,n!=0
;
0			[ 0
foo			[ 0
10			[ 0 1
foo			[ 0 1
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if

#{if step>=59
[ // The loop control structures are:
[ // loop{ ... }while{ ... }loop and loop{ ... }until{ ... }loop

[ // loop{ just needs to leave a pointer to refer back to the start of the loop
: loop{
	here	[ here (here:h)
	@	[ h
;
immediate
[	// this is just a few dummy }}{ to balance out the unbalanced braces
[ // An obvious way to think of }while{ is that it is just an if{ within a loop
: }while{
	[compile] if{	[ l	// to compile an if{ despite its immediacy
;
immediate
[	// this is just a few dummy }}}{{ to balance out the unbalanced braces
[ // And a }loop is just an }else{ within a loop, but with a backward jump
: }loop				[ h l
	[compile] }else{	[ h l	// compile an }else{ despite immediacy
	swap			[ l h
	patch			[	// back patch with a -ve offset
;
[	// this is just a few dummy } to balance out the unbalanced braces
immediate
#{ifdef TESTROM
: fib			[ i:n
	1		[ i a:1
	0		[ i a b:0
	loop{		[ i a b		// a>b
		over	[ i a b a
		+	[ i a c:b+a
		swap	[ i c a
		third	[ i c a i
	}while{		[ i c a		// i!=0
		rot	[ c a i
		dec	[ c a i:i-1
		rot	[ a i c
		rot	[ i c a
	}loop		[ i c a		// i==0
	drop		[ i c
	nip		[ c		// c=fibonacci(n), n>=1
;
10			[ 10	// +2
fib			[ 144	// fibonacci(10+2)
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if

#{if step>=60
[	// this is just a few dummy { to balance out the unbalanced braces
[ // }until{ is just like }while{ except the jump condition is reversed
: }until{
#{if THREAD!=3
#{if prim_var_deref==1
[ THREAD==1 and prim_var_deref==1 => x86-user
[ THREAD==4 and prim_var_deref==1 => msp430-stc
[ THREAD==5 and prim_var_deref==1 => msp430-fcode
	#jnz
#}if
#{if prim_var_deref!=1
	lit	[	// lit escapes the following byte(s)
	jnz	[ jnz	// escaped by lit
#{if offset==1
	lit	[ jnz	// padding used for 1 byte offset, escaped by lit
#}if
#{if offset==3
	pad0 pad0 pad0	[ jnz	// padding escaped by lit
#}if
#{if offset==7
	pad0 pad0 pad0 pad0 pad0 pad0 pad0	[ jnz // padding escaped by lit
#}if
#}if
#}if

#{if THREAD==3
	#jnz	[ jnz	// since thread type3 cannot use the above trick
#}if
#{if THREAD!=4
	offset,	[ \ jnz
	offset	[ h \ 0
#}if
#{if THREAD==4

#{if ARCH eq "msp430"
[ // machine code for the "conditional jump if non zero" looks like this:
[ //	0c172: 27 83                     DECD    R7
[ //	0c174: 06 f6                     AND     R6,     R6
[ //	0c176: 26 47                     MOV     @R7,    R6
[ //	0c178: 0b 20                     JNZ     0xc190
[ // Since jnz_cfa has the code for the preamble, just generate a call to it
[ // and then reserve 2 bytes for the actual jump itself to be "patch"ed later
	compdef	[ \ call jnz_cfa // appended to the dictionary to call preamble
	8192	[ 0x2000	// MSP 430 uses 2 bytes for a conditional jump
	,	[ \ 0 0x20	// 6 bits opcode for JNZ + 10 bits jump offset
	here	[ here		// the 10 bit jump offset is zero filled
	@	[ h		// and will be "patch"ed later
#}if

#{if ARCH eq "z80"
[ // machine code for the "conditional jump if non zero" looks like this:
[ //	000153 7B               [ 4] 277  ld a, e
[ //	000154 B2               [ 4] 278  or a, d
[ //	000155 CD 3C 00         [17] 279  CALL realdrop
[ //	000158 20 06                 280  JR NZ, lbl043_endloop
[ // Since jnz_cfa contains the first 6 bytes that are needed, copy them as is
[ // and then reserve 1 byte for the actual jump offset to be "patch"ed later
	dup	[ jnz_cfa jnz_cfa (jnz_cfa:0xB27B)
	@	[ jnz_cfa 0xB27B
	,	[ jnz_cfa \ 0x7B 0xB2
	2 +	[ j2:jnz_cfa+2
	dup	[ j2 j2 (j2:0x3CCD)
	@	[ j2 0x3CCD
	,	[ j2 \ 0xCD 0x3C
	2 +	[ j4:j2+2 (j4:0x2000)
	@	[ 0x2000
	,	[ \ 0x00 0x20
	0 c,	[ \ 0		// reserved for the offset
	here	[ here
	@	[ h
#}if

#}if
;
immediate
: ==		[ a b
	-	[ a-b
	0=	[ a==b
;
[	// this is just a few dummy } to balance out the unbalanced braces
#{ifdef TESTROM
: sum			[ n
	0		[ n a:0
	0		[ n a i:0
	loop{		[ n a i
		third	[ n a i n
		over	[ n a i n i
		==	[ n a i n==i
	}until{		[ n a i		// n!=i
		tuck	[ n i a i
		+	[ n i a:a+i
		swap	[ n a i
		inc	[ n a i:i+1
	}loop		[ n a i		// n==i
	drop		[ n a
	nip		[ a
;
10			[ 10
sum			[ 45=10*9/2
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if

#{if step>=61
[ A definition of for{ ... }for loops in terms of regular while loops
: for{				[ i:index n:limit	// for loop over [i:n)
	[compile] loop{		[ i n			\ loop{
	compile over		[ i n i			\	over
	compile over		[ i n i n		\	over
	compile >r		[ i n i		|   n ] \	>r
	compile >r		[ i n 		| i n ] \	>r
	compile -		[ i-n		| i n ] \	-
	[compile] }while{	[		| i n ] \ }while{	// i!=n
;
immediate
: }for				[		| i n ]
	compile r>		[ i		|   n ] \	r>
	compile inc		[ i:i+1		|   n ] \	inc
	compile r>		[ i n		|     ] \	r>
	[compile] }loop		[ 		| i n ] \ }loop		// i==n
	compile r>		[ i		|   n ]	\ r>
	compile drop		[		|   n ] \ drop
	compile r>		[ n		|     ] \ r>
	compile drop		[		|     ] \ drop
;
immediate
#{ifdef TESTROM
: sum			[ n
	0		[ n a:0
	swap		[ a n
	0		[ a n i:0
	swap		[ a i n
	for{		[ a	| i n ]
		i	[ a i	| i n ]
		+	[ a:a+i	| i n ]
	}for		[ a
;
10			[ 10
sum			[ 45
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if

#{if step>=62

: def{ : ;
: }def [compile] ; ; immediate

def{ nybble			[ d
	15			[ d 0xf
	&			[ d&0xf
	dup			[ d d
	10			[ d d 10
	>=			[ d d>=10
	if{			[ d // d>=10
		10 - 65 +	[ D:d-10+'A'
	}else{			[ d // d<10
		48 +		[ D:d+'0'
	}if			[ D
	emit			[ > D
}def

def{ .			[ n
	32 emit		[ n > SPACE
	48 emit		[ n > 0
	120 emit	[ n > x
	2 3 <<		[ n s:2*8 // length of the display is fixed at 16 bits
	loop{		[ n s
		dup	[ n s s
	}while{		[ n s
		4 -	[ n s:s-4
		2dup	[ n s n s
		15	[ n s n s 0xf
		swap	[ n s n 0xf s
		<<	[ n s n m:0xf<<s
		&	[ n s i:n&m
		over	[ n s i s
		>>	[ n s d:i>>s
		nybble	[ n s > d
	}loop		[ n s
	2drop		[
	32 emit		[ > SPACE
}def

#{ifdef TESTROM
49406			[ 0xC0FE	// this could be used as a version #
.			[ > 0xC0FE
3ret
#}ifdef

#}if

#{if step>=55
#{ifdef TESTROM
: foo 12345 ; foo 
latest @ @ latest ! 
3ret 
#}ifdef
#}if
#{if step>=56
: [ 10 parse 2drop ; immediate [ comments should start working from here on out
#{ifdef TESTROM
: foo		[	// verify that comments work within definitions as well
	4321	[ 4321
; foo 		[	// and invoke foo for later verification
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret			[ // and switch back to test from within the outer repl
#}ifdef
#}if
#{if step>=57
[ // Reserve a zero-filled patch'able byte/cell for storing a branch offset
: offset
	0	[ 0
	offset,	[ \ 0
	here	[ here
	@	[ h
;
[ // if{ is just syntax sugar replacement for the traditional Forth IF keyword
: if{
#{if THREAD!=3
	lit	[	// lit escapes the following byte(s)
	jz	[ jz	// escaped by lit
#{if offset==1
	lit	[ jz	// padding used for 1 byte offset, escaped by lit
#}if
#}if

#{if THREAD==3
	#jz	[ jz	// since thread type3 cannot use the above trick
#}if
	offset,	[ \ jz
	offset	[ h \ 0
;
immediate

#{if THREAD==3
[ Store s, a little-endian short at address a such that a[0,1]==(lo(s),hi(s))
[ s! is needed by the C port where the jump offset is a short (uses 16 bits)
[ since c! works only on bytes and ! works only on int (ie 32 bit) sized values
: s!		[ s a
	2dup	[ s a s a
	c!	[ s a (a:s)
	inc	[ s h:a+1
	swap	[ h s
	8	[ h s 8
	>>	[ h t:s>>8
	swap	[ t h
	c!	[ (h:t)
;
#}if

[ // patch is used to back patch the offset which was generated by "offset"
: patch		[ o h
	over	[ o h o
	-	[ o n:h-o
#{if THREAD==3
	1	[ o n 1		// for thread type3, the offset needs to be
	>>	[ o n:n>>1	// divided by 2 since C does a pointer addition
#}if
	swap	[ n o
	dec	[ n a:o-1
#{if THREAD==1
	c!	[ (a:n)
#}if
#{if THREAD==2
	dec	[ n a:a-1
	!	[ (a:n)
#}if
#{if THREAD==3
	dec	[ n a:a-1
	s!	[ (a:n)
#}if
;
[ // }if is just syntax sugar replacement for traditional Forth's THEN
[ // it patches up the reserved offset saved on the stack at the start
: }if		[ o
	here	[ o here
	@	[ o h
	patch
;
immediate
[ test if{ ... }if using a simple definition:
[ ?dup : dup's the tos only if it is non-zero
: ?dup			[ n
	dup		[ n n
	if{		[ n	// n != 0
		dup	[ n n
	}if		[ n n?	// not dup'ed if n==0
;
#{ifdef TESTROM
0	[ 0
?dup	[ 0
1	[ 0 1
?dup	[ 0 1 1
3ret
#}ifdef
#}if
#{if step>=58
[ "jump" compiles in the "j" operator and the placeholder for the offset
: jump
#{if THREAD!=3
	lit	[	// lit escapes the following byte(s)
	j	[ j	// escaped by lit
#{if offset==1
	lit	[ j	// padding used for 1 byte offset, escaped by lit
#}if
#}if

#{if THREAD==3
	#j	[ j	// since thread type3 cannot use the above trick
#}if
	offset,	[ \ j
	offset	[ h \ 0
;
[ compile the "immediate" word following it by setting the override flag
: [compile]
	override!
;
immediate

[	// this is just a few dummy {{{ to balance out the unbalanced braces

[ }else{ can be treated as an unconditional branch followed by }if
: }else{		[ o
	jump		[ o h	// compile the unconditional branch
	swap		[ h o
	[compile] }if	[ h	// to compile an }if despite its immediacy
;
immediate
#{ifdef TESTROM
: foo			[ n
	if{		[	// n!=0
		1	[ 1
	}else{		[	// n==0
		0	[ 0
	}if		[ 0,n==0;1,n!=0
;
0			[ 0
foo			[ 0
10			[ 0 1
foo			[ 0 1
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if
#{if step>=59
[ // The loop control structures are:
[ // loop{ ... }while{ ... }loop and loop{ ... }until{ ... }loop

[ // loop{ just needs to leave a pointer to refer back to the start of the loop
: loop{
	here	[ here (here:h)
	@	[ h
;
immediate
[	// this is just a few dummy }}{ to balance out the unbalanced braces
[ // An obvious way to think of }while{ is that it is just an if{ within a loop
: }while{
	[compile] if{	[ l	// to compile an if{ despite its immediacy
;
immediate
[	// this is just a few dummy }}}{{ to balance out the unbalanced braces
[ // And a }loop is just an }else{ within a loop, but with a backward jump
: }loop				[ h l
	[compile] }else{	[ h l	// compile an }else{ despite immediacy
	swap			[ l h
	patch			[	// back patch with a -ve offset
;
[	// this is just a few dummy } to balance out the unbalanced braces
immediate
#{ifdef TESTROM
: fib			[ i:n
	1		[ i a:1
	0		[ i a b:0
	loop{		[ i a b		// a>b
		over	[ i a b a
		+	[ i a c:b+a
		swap	[ i c a
		third	[ i c a i
	}while{		[ i c a		// i!=0
		rot	[ c a i
		dec	[ c a i:i-1
		rot	[ a i c
		rot	[ i c a
	}loop		[ i c a		// i==0
	drop		[ i c
	nip		[ c		// c=fibonacci(n), n>=1
;
10			[ 10	// +2
fib			[ 144	// fibonacci(10+2)
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if
#{if step>=60
[	// this is just a few dummy { to balance out the unbalanced braces
[ // }until{ is just like }while{ except the jump condition is reversed
: }until{
#{if THREAD!=3
	lit	[	// lit escapes the following byte(s)
	jnz	[ jnz	// escaped by lit
#{if offset==1
	lit	[ jnz	// padding used for 1 byte offset, escaped by lit
#}if
#}if

#{if THREAD==3
	#jnz	[ jnz	// since thread type3 cannot use the above trick
#}if
	offset,	[ \ jnz
	offset	[ h \ 0
;
immediate
: ==		[ a b
	-	[ a-b
	0=	[ a==b
;
[	// this is just a few dummy } to balance out the unbalanced braces
#{ifdef TESTROM
: sum			[ n
	0		[ n a:0
	0		[ n a i:0
	loop{		[ n a i
		third	[ n a i n
		over	[ n a i n i
		==	[ n a i n==i
	}until{		[ n a i		// n!=i
		tuck	[ n i a i
		+	[ n i a:a+i
		swap	[ n a i
		inc	[ n a i:i+1
	}loop		[ n a i		// n==i
	drop		[ n a
	nip		[ a
;
10			[ 10
sum			[ 45=10*9/2
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if
#{if step>=61
[ A definition of for{ ... }for loops in terms of regular while loops
: for{				[ i:index n:limit	// for loop over [i:n)
	[compile] loop{		[ i n			\ loop{
	compile over		[ i n i			\	over
	compile over		[ i n i n		\	over
	compile >r		[ i n i		|   n ] \	>r
	compile >r		[ i n 		| i n ] \	>r
	compile -		[ i-n		| i n ] \	-
	[compile] }while{	[		| i n ] \ }while{	// i!=n
;
immediate
: }for				[		| i n ]
	compile r>		[ i		|   n ] \	r>
	compile inc		[ i:i+1		|   n ] \	inc
	compile r>		[ i n		|     ] \	r>
	[compile] }loop		[ 		| i n ] \ }loop		// i==n
	compile r>		[ i		|   n ]	\ r>
	compile drop		[		|   n ] \ drop
	compile r>		[ n		|     ] \ r>
	compile drop		[		|     ] \ drop
;
immediate
#{ifdef TESTROM
: sum			[ n
	0		[ n a:0
	swap		[ a n
	0		[ a n i:0
	swap		[ a i n
	for{		[ a	| i n ]
		i	[ a i	| i n ]
		+	[ a:a+i	| i n ]
	}for		[ a
;
10			[ 10
sum			[ 45
latest @ @ latest !	[ // clean up after ourselves to restore the dictionary
3ret
#}ifdef
#}if
#{if step>=62
: def{ : ;
: }def [compile] ; ; immediate
def{ .			[ n
	32 emit		[ n > SPACE
	48 emit		[ n > 0
	120 emit	[ n > x
	cell 3 <<	[ n s:cell*8
	loop{		[ n s
		dup	[ n s s
	}while{		[ n s
		4 -	[ n s:s-4
		2dup	[ n s n s
		15	[ n s n s 0xf
		swap	[ n s n 0xf s
		<<	[ n s n m:0xf<<s
		&	[ n s i:n&m
		over	[ n s i s
		>>	[ n s d:i>>s
		15	[ n s d 0xf
		&	[ n s d&0xf
		dup	[ n s d d
		10	[ n s d d 10
		>=	[ n s d d>=10
		if{			[ n s d // d>=10
			10 - 65 +	[ n s D:d-10+'A'
		}else{			[ n s d // d<10
			48 +		[ n s D:d+'0'
		}if	[ n s D
		emit	[ n s > D
	}loop		[ n s
	2drop		[
	32 emit		[ > SPACE
}def
#{ifdef TESTROM
49406			[ 0xC0FE	// this could be used as a version #
.			[ > 0xC0FE
3ret
#}ifdef
#}if

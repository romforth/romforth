# gencode : native code generation for the IBM 1130
#
# Copyright (c) 2025-2026 Charles Suresh <romforth@proton.me>
# SPDX-License-Identifier: AGPL-3.0-only
# Please see the LICENSE file for the Affero GPL 3.0 license details

do "./mapnames"; # to handle the IBM 1130 assembler 5 character label limit

sub chord {
	my ($c)=@_;
	return ord($c);
}

sub lit {
	my ($l)=@_;
	my $o=$l->[1];
	print qq(\tdc\t\tlit\n);
	print qq(\tdc\t\t);
	if ($o=~/^[a-z]+/) {
		$o=mapany($o,$o);
		print "$o\n";
		return;
	}
	if ($o < 0) {
		$o = (1<<16)+$o;
	}
	printf("/%x", $o);
	print qq(\t# $o : dup ; tos <- $o\n);
}

sub compile {
	my ($l)=@_;
	my $o=$l->[1];
	print qq(\tdc\t\tlit\n);
	print qq(\tdc\t\t$o\n);
}

sub prim {
	my ($w)=@_;
	my $o=$w->[1];
	$o=maplbl($o,$o);
	print "\tdc\t\t$o\t; $w->[2]\n";
}

my $jmp='';

sub word {
	my ($w)=@_;
	my $o=$w->[1];
	if ($o eq 'j') { $jmp='j' ; return; }
	if ($o eq 'jz') { $jmp='jz' ; return; }
	if ($o eq 'jnz') { $jmp='jnz' ; return; }
	$o=mapany($o,$o);
	print "\t$o ; $w->[1]\n";
}

sub skip {
	my ($s)=@_;
	my $o=$s->[1];
	print "\tdc\t\t$o\n";
}

my $label;
sub setlabel {
	my ($l)=@_;

	# the IBM 1130 assembler only allows labels of length 5 so we
	# extract the first letter and the 3 digits and reserve the last
	# slot for a suffix character to be added later (in cond/loop)
	$l=~/^(.)[^\d]*(\d+)/;
	$label="$1$2";
}

sub cond {
	my ($s)=@_;
	my $i=$s->[1];	# AST for the 'if' part
	my $e=$s->[2];	# AST for the 'else' part
	print "\tdc\t\tjz\n";
	print "\tdc\t\t$label", "t-*\n";
	my ($l,$c)=($label++, "t");
	my $si = walk($i);	# expand out the 'if' part of the AST
	if (defined $e and @$e != 0) {
		print "\tdc\t\tj\n";
		print "\tdc\t\t$l", "f-*\n";
		print $l, $c, "\n";
		$c='f';
		my $se = walk($e);	# expand out the 'else' part of the AST
	}
	print $l, $c, "\n";
}

my $gendict=0;
sub setgendict {
	my ($v)=@_;
	$gendict=$v;
}

my $prev="0";

sub def {
	my ($s)=@_;
	my ($k,$w,$l,$imm,$p,$a)=@$s;
	print "\t\t\t\t\t# $k name:$w, label:$l, imm: $imm\n";
	$l=maplbl($l,$w);
	if ($gendict) {
		my $len=length($w);
		# print "\t.align 1\n";
		if ($len%2==0) {
			#print "$l","_pad:\t.db 0\n";
		}
		for my $c (split(//,$w)) { # cannot use dmes instead of .ascii
			print qq{\tdc\t\t}, chord($c), "\n";
		}
		$len |= 0x80 if ($imm);
		print "$l","n\tdc\t\t$len\n";
		my $lfa=$p;
		die "$p" unless ($lfa=~/^(.+)\_lfa/);
		my $n=maplbl($1,$lfa);
		$n.='l';
		print "$l","l\tdc\t\t$n\n";
		$prev=$p;
		$prev="$l"."l";
	}
	print "$l", "c\t\t\t\t\t# $w\n";
	my $se = walk($a);	# expand out the body of the definition
	print "\tdc\t\texit\n";
}

sub visit {
	my ($s)=@_;
	#print "$s->[0]  label:$s->[1],  name:$s->[2]\n";
	my $l=$s->[1];
	if (length($l)>5) {
		$l=~s/^lbl/l/;
	}
	$l=maplbl($l,$l);
	print "\tdc\t\tente\n";	# that's IBM 1130 for enter ;)
	print "\tdc\t\t$l", "c\t# $s->[2]\n";
}

sub loop {
	my ($l)=@_;

	# loop can be invoked in a couple of different scenarios:
	# 1. an unconditional loop such as : [ 'loop', [...] ]
	# 2. or as a 'while' loop : [ 'loop', [...], 1, [...] ]
	# 3. or as an 'until' loop : [ 'loop', [...], 0, [...] ]

	my $t; # denotes the 'type' of the loop:
	# type -1 means unconditional, 0 is for until and 1 for while

	my $c=$l->[1];	# the conditional/first part of the loop
	my $lbl=$label++;
	print "$lbl", "b\n";
	my $lc = walk($c);

	my $b=$l->[2];		# this could be either the type or undefined
	if (defined $b) {	# conditional loop
		$t=$b;		# set to either 1: while or 0: until
		$b=$l->[3];	# get the actual body of the loop
	} else {		# unconditional loop
		$t=-1
	}
	if ($t==1) {		# conditional while loop
		print "\tdc\t\tjz\n";
		print "\tdc\t\t$lbl", "e-*\n";
	} elsif ($t==0) {	# conditional while:until loop
		print "\tdc\t\tjnz\n";
		print "\tdc\t\t$lbl", "e-*\n";
	} else {		# unconditional loop
		# no condition code needs to be generated
	}
	my $lb = walk($b);
	print "\tdc\t\tj\n";
	print "\tdc\t\t$lbl", "b-*\n";
	print "$lbl", "e\n";
}

sub header {
	my ($k,$w,$l,$imm,$prev,$var)=@_;
	my $len=length($k);
	#print qq{\tdmes\t\t$k\n};
	for my $c (split(//,$k)) { # cannot use dmes (in place of .ascii)
		print qq{\tdc\t\t}, chord($c), "\n";
	}
	$l=maplbl($l,"$l : $w");
	print "$l","n\tdc\t\t$len\n";
	print "$l","l\tdc\t\t$prev\n";
	$prev="$l"."l";
	print "$l", "c\t\t\t\t; $k\n";
	if ($var) {
		print qq(\tdc\t\tlit\n);
		print qq(\tdc\t\t$l\t#	$l ; tos <- $l\n)
	}
	return $prev;
}

sub ret {
	print "\tdc\t\texit\n";
}

sub fullheader {
	my ($k,$v,$prev,$var)=@_;
	my ($w,$l,$imm,$a)=@$v;
	$prev=header($k,$w,$l,$imm,$prev,$var);
	#print join("", @$a) if ($var==0);
	$l=maplbl($l,"$l : $w");
	print "\tdc\t\t$l\n" if ($var==0);
	ret();
	return $prev;
}

sub latest {
	open(my $lh, ">latest.s");
	print $lh "\tdc\t\t$prev\n";
	close $lh;
}

1;

INDEX
-----
	* 11 Nov '22
	* 13 Nov '22
	* 15 Nov '22
	* 18 Nov '22
	* 30 Nov '22
	* 01 Dec '22
	* 03 Dec '22
	* 05 Dec '22
	* 06 Dec '22
	* 07 Dec '22
	* 08 Dec '22
	* 09 Dec '22
	* 12 Dec '22
	* 15 Dec '22
	* 16 Dec '22
	* 18 Dec '22
	* 19 Dec '22
	* 20 Dec '22

11 Nov '22
----------
The difficulty I'm running into now with the C port is that it is turning into
what appears to be a long drawn out struggle between C and Forth to figure out
who has first dibs on access to the system.

Forth obviously considers the entire machine as personal property unto itself,
to treat as it wishes. For example, Forth needs access to the return stack but
modifying the return stack in C looks like a fairly heavyweight operation using
getcontext/setcontext or other lower level alternatives using "asm"

There is also clearly an impedance mismatch between Forth's view of memory and
the memory abstraction that C provides - especially since the Forth bit'ness
of this implementation by design is 16 bits vs whatever processor bit width it
happens to be on the system that the C compiler is running on.

Rather than go into contortions trying to make the two world views conform to
fit each other, I'll call this port to C complete, for the most part, since new
Forth definitions can be added to defs.4th (although clipping its wings like
this makes for a very crippled/powerless Forth implementation).

So it does look like there is a real need for direct access to the CPU to have
Forth's power shine forth, so I think I'll go back to the original roadmap and
pick up things back up from where I left off, looking at what port to do next.

13 Nov '22
----------
Rather than jump directly into selecting a processor for the next round of the
porting exercise, I decided to take a step back to look at where I could be
more productive and not waste time on repetitive grunt work.

So now that I've done the porting exercise a couple of times, one thing that
I've found which appears to be a serious waste of time is starting over from
scratch for each port with an empty rom.4th and then adding the same generic
code over and over again after each step as the port progresses. For example,
the rom.4th changes to verify the key/emit functionality was done in commit
589f315d74e90e3e097112dc8760b41cdf958a22 at the time of the initial bootstrap.
At the time of "porting" this change to GNU "as", the same set of changes was
done in rom.4th at commit 2eba44f4643e42c98b8cf654c3936a333a4e225d. This was
repeated yet again at the time of the C port, when the exact same set of
changes to rom.4th was made in commit 07c25aaf30e1a7dc0a566adc086e3d0a3f896519

So rather than repeat this for each port, it makes sense to abstract out
the generic code in rom.4th and delimit each step of the porting process
within that file so that we can increase a "step" variable after each step
of the porting process so that when all the "steps" are complete, and all the
tests run successfully, we can declare that port complete.

This removes all of the duplicated effort that goes into keeping the tests
(which are part of rom.4th) in sync with each of the porting steps. Instead
of that approach, the new process ensures that the rom.4th contents remain
the same for all ports and the only thing that changes is the "step" variable
(which in some sense denotes the progress of a specific port).

Only time will tell if this "premature standardization" is a good thing or not.

As part of this process, I've also decided to add yet another primitive and
sneak it into the rom.4th "standard" as part of this overhaul. The primary
reason to add it in is for symmetry with "pick". For lack of a better name,
I'm calling it "stick" and like "pick", which gets an element from the stack,
"stick" replaces an element in the stack with a new value.

To parameterize individual ports, I've added a provision for Perl/shell-like
"dollar" variables. Since the code processor does not yet exist, I've not
modified the existing rom.4th files but created the new/generic version at
the top level. As this gets fleshed out and tested, the other rom.4th files
will be eventually obsoleted and removed.

---

That's it for the technical part of this journal entry. On a personal note,
as of today, it is 13 years since Lisa died. She would have been just the age
at which I was getting into the swing of all things related to coding. I wonder
if she would have chosen to be a coder like me.

Anyway, miss you Lisamma.

15 Nov '22
----------
I'm yet again at the crossroads of choosing a processor to work on next and as
with the earlier choice that was made, of fleshing out the generic test code in
rom.4th first, I've chosen to again start off by writing up what amounts to an
elaborate and generic how-to/"process document" on how to go about the porting
exercise for any given processor. It is meant to match up with the "step"s in
the rom.4th test cases although there isn't an exact 1-1 correspondence since
this "code" is meant to be more for human consumption than for direct use by
machine.

This is also an attempt to consolidate the things I've learnt from the previous
round of porting exercises that have been completed so far and the expectation
is that this "code" will continue to be updated with newer ideas as I work on
additional ports for other CPUs.

Since it is written for a "generic" CPU, I've placed it under pseudo/code since
much of the "code", if you want to call it that, is a mishmash of C and Forth
along with some non-C like notation for auto increment/decrement borrowed from
6809 assembly code. Although it is pseudo-code I've written it in a way such
that it may be possible to write a parser for it and turn it into machine code.

18 Nov '22
----------
This is starting to become a pattern now I guess: everytime I think I should
start on a new port, the overhang of the previous work takes me off on yet
another tangent. In this case it is an attempt to make sure that the new
version of the tests in rom.4th can actually work seamlessly with the original
code. The newer version of rom.4th had some changes from the version in the
port directories so I assume it is wise to test stuff out now on known code
rather than figure things out the hard way on unknown code where I'm wrangling
a new CPU and new toolchain along with the newer tests. It will also prove
if this strategy was a good choice to begin with.

30 Nov '22
----------
I think the x86 port is now complete (yes, really, at least to my satisfaction)
now that the last of the annoying little techdebt details are cleared. So I can
declare unambiguosly that it is now time to start on the next port.

In the initial list of architectures that I had listed in the PORTING doc, I
realized that I missed a truly important one: the PDP11 (I've updated it there
now). In my early student days, we covered the PDP11 as part of the course on
"Computer Organization" based on the textbook of the same name authored by
V. Carl Hamacher, Zvonko G. Vranesic and Safwat G. Zaky.

---

A small personal anecdote about this book : I bought this book long, long ago
when I was a student (when it, quite literally, cost a fortune). From the
scribbles on the back of the book, it looks like the price was $7.95 (USD? or
more likely Singapore Dollar, since it is the "International Student Edition"
printed in Singapore) and it was sold for the princely sum of Indian Rs 125/-
which in my student days would probably have been about ~2-4 months worth of
lunch money. This was in the late 80's so I'm really dating myself here. I'm
really grateful that my Dad (Happy Birthday, Apai!) and Mom plunked down their
hard earned money to buy this book for me.

Thank you Apai & Mom! :heart: :RIP:

---

Switching back to the technical discussion, the pseudo code (in pseudo/code)
that I wrote to help with the porting reminded me of how well attuned the PDP11
instructions are to the programmers needs from an assembly coding point of view

I'll assume that the instruction sets of the 68000 and the MSP430, both of
which are elegant in their own ways, all trace their lineage back to this
beautifully crafted, gem of an ISA. Obviously, I can only talk about what I
know, so in case the PDP11 inherited its elegance from an earlier design, then
hey, here's a shout out to them too.

Some research into how to emulate a PDP11 and cross-compile/build for it led me
to: https://ancientbits.blogspot.com/2012/07/programming-barebones-pdp11.html
which walks through all of the steps required to do this in excellent detail.

The quick summary/cheatsheet is:
- Build/install binutils (for pdp11-aout-as and pdp11-aout-ld)
- Build/install simh to emulate the PDP11
- Build bin2load from https://github.com/jguillaumes/retroutils
  This utility is used to modify the a.out binary generated by the pdp11 as/ld
  into a "lda" binary which can be load'ed directly by simh during emulation.

Using these instructions I was able to successfully complete the "Preamble"
step of porting documented in pseudo/code for the PDP11 port.

01 Dec '22
----------
Starting at step 0 of the porting work for PDP11 brought me back to yet another
round of thinking about the format of code.prims. So far, I've used the
	code{ ... }code, inner{ ... }inner and fallthru
among other directives for the assembly language primitives of the x86 ports
but looking back at it now, I find all of that a bit too verbose compared to
the spareness of Forth's own : ... ; notation. So as an experiment, I'm going
to try doing an exercise in extreme minimalism: what if assembly code did not
use any type of decoration whatsoever?

So the plan is that assembly code will be written in code.prims in the format:
	forthlabel : assembly-line1 ; assembly-line2 ; ... ;
all on one line to improve the "code density". The "forthlabel" is just the
conventional forth word name and the assembly code delimited by the semicolons
implement that word.

Since this will be preprocessed by the genprims script anyway, I'm thinking of
putting a spin on it though, where ';' will serve multiple purposes which
hopefully won't cause me too much confusion down the line.

As mentioned above, the ';' serves to delimit independent assembly code lines
but the new spin on it is that it also serves to denote calling "next" if it
is the terminating character on a line. If the line is not terminated by a
semicolon, the expectation is that the code will fall through to the next line
of code below it. So code blocks that currently looks like this:

	code{
	foo bar
		line1
		line2
		...
	}code

will turn into this:

	foo : line1 ; line2 ; ...

Note that the assembly label "bar" in the original code is no longer needed
since it will be auto-generated by the genprims script. In the initial x86
port, "bar" was usually a copy of "foo" if "foo" was alphanumeric (for example
"emit emit") or an alphanumeric replacement (for example "@ fetch"). I've
tried to semi-automate this by using the forth label if it is alphanumeric.

Similarly, inner{ ... }inner code blocks that currently looks like this:

	inner{
	foo bar
		line1
		line2
		...
	}inner

will turn into this:

	foo : line1 ; line2 ; ... ;

Note the addition of the terminating ';' in case of "inner" blocks which is
meant to denote adding the implicit call to "next".

Code blocks that needed "fallthru" can also be denoted in the new scheme just
by leaving out the terminating semicolon. Hopefully, this will make for a much
shorter and crisper implementation.

Although the purpose of the overall project is to showcase a really small Forth
implementation, simh/PDP11 provides me 64K of RAM which is such a luxury that
I'm going on a splurge and use an entire 16 bits for each word offset. This is
a code size win even for jsr calls so I'm not going to go into contortions to
reduce the offset down to 8 bits - although that should be fairly easy as well.

03 Dec '22
----------
Getting output to the console working under simh was not too much of a hassle
since I was continuing to follow the really helpful notes at
https://ancientbits.blogspot.com/2012/07/programming-barebones-pdp11.html

I did simplify the code, a lot, though, based on the sample code from the
"PDP11 Peripherals and Interfacing Handbook", an online copy of which is
available from:
http://www.bitsavers.org/pdf/dec/pdp11/handbooks/PDP11_PeripheralsHbk_1972.pdf

Although I initially used the console device for output, one difficulty I ran
into with using it was with trying to redirect that output to a named file. In
the end, I decided that the struggle was not worth it and just decided to use
a different device (the line printer, LPT/LP11) since simh allows it to be
directly attach'ed to a named file.

Next, I just need to do the same thing for console input as well. Let's see
how long figuring that one out takes.

05 Dec '22
----------
Sometimes it is the simplest things that take the longest to get done. It turns
out the premonition I had about redirecting the input from a file as mentioned
in my previous journal entry turned out to be fairly spot on.

My first attempt at implementing "key" was to use the console device and it
worked without much debugging - using the sample code from Digital in the
"PDP11 Peripherals and Interfacing Handbook" available from:
http://www.bitsavers.org/pdf/dec/pdp11/handbooks/PDP11_PeripheralsHbk_1972.pdf
came in pretty handy again.

Since I want to be able to automate the testing though, the next attempt was
to redirect the input from a file. I initially tried to use the same approach
that succeeded for me with "emit" (where I used the LPT device instead of the
DL11 console output). I thought I could attach the "Paper Tape Reader"/PC11/ptr
device to the input file and change the addresses from 017756X to 017755X and
call it a day. But for some unknown reason I haven't been able to get that
working so far. Running ex'amine on the device shows that the data exists as
expected but the code kept looping as if the data wasn't available. Rather than
spend even more time on trying to fix whatever was broken, I decided to read
through the simh docs to see if there was another device I could test instead
but happened to see the "send" command that allows you to inject data into the
console input. So for now, I've decided to use that feature as a workaround.

Given the time I've spent trying to get this working on simh, I now wonder if
it wouldn't have been faster to just write yet another emulator for the pdp11
just like I did for the x86. Perhaps, if I get stuck again, that's just what
I'll do.

06 Dec '22
----------
For implementing the data stack on the PDP11, there is a literal profusion of
choices since any of the PDP11 registers can be used as the data stack pointer
(given the PDP11's flexible addressing modes).

Since I want to see if the native/machine stack can be used for the return
stack, I'll choose the next available register (r2), rather than r6 as the
data stack pointer. The current register mapping is: R0: IP, R1: TOS, R2: SP

The remaining decision is about where to place the data stack. I'll make the
same choice that I made on the x86 port, which is to have it grow to low memory
starting from the beginning of the text area. So the current memory layout
looks like this:

			0x100 -> higher memory
	  ------------------------------
	   <- data stack | code/text ->
	  ------------------------------

07 Dec '22
----------
During the x86 port, I chose to use the macro features of the x86 assembler
to do all of the macro expansions that were needed when a Forth word used a
"lower" level forth word. For the PDP11 port though, I want to try something
different and have most of those expansions done by genrom instead. This seems
to be a cleaner approach than the ugliness of the x86 version where I have
to disambiguate between the macro expansion and a regular call by using '_' to
prefix the words that needed to be expanded.

So this required a little bit of addition to genrom's capabilities.

In the x86 port, I was using 8 bit offsets so all of the addresses were stored
as offsets from the base of the text area. Since I'm using the full 16 bits
for the PDP11 port, I can store the addresses as is.

08 Dec '22
----------
While working my way through "step 5" to implement conditionals on the PDP11
I decided that the scope of this step is too large and needs to be broken up
into smaller steps which are finer grained and more easily tested.

I also found that using "jmp" as a label seems to cause a hiccup for the
PDP11 assembler so it needs to be renamed to something other than "jmp".
I'll pick "j" as the replacement name, for now.

So, my solution to address these issues is to separate out the support for
implementing the primitives "j/jz/jnz" into 3 sub-steps which I'm calling
steps 4.1, 4.2 and 4.3 and then follow that up with the implementation for
"if{ ... }else{ ... }if" in genrom (which remains the same as before) as
part of the original "step 5".

I chose to use the floating point notation for the newer steps since it
allows me to not have to redo the numbering for all of the the other later
steps, thus keeping those step numbers the same, just in case they are
referred elsewhere.

Since it is quite useful to be able to test each of the basic "j/jz/jnz"
primitives independently of the language support (which is only added later
in "step 5"), some standalone/newer tests for these steps have been added
to rom.4th as well. This change then snowballed into requiring changes to
test.inp and test.expected as well. So while I was there I decided to clean
up the conditions used for the earlier tests from "step>N-1" to "step>=N"
which makes it easier to match up each test with the corresponding "step"
during coding and testing.

Since more granular steps are being added, I decided it is safer to test
it all out on the x86 ports first before trying it out on the PDP11 port.

One addition that I've made to the genrom feature set is the ability to
use "immediate offsets" which are different from the "immediate literals".
The "literals" are the usual Forth literals prefixed with the lit operator
and can be denoted as bare numbers/variables or prefixed with the $ notation.

The "offsets" are new and are used for encoding JUMP offsets which don't
need to be prefixed with 'lit' - they are denoted using a '#' prefix.

09 Dec '22
----------
Today was a fairly productive day as I cranked away at most of the easy
parts of the port. The next set of primitives are the hard ones since they
usually require you to pay attention to a lot of detail. I did start off
thinking about how to implement exec/enter/exit/call and have some ideas
about tying it to the PDP11 JSR instruction but that needs me to use the R6
register instead of the R4 register which is used currently.

I'm tired now though and I think all of that can wait for another day.

12 Dec '22
----------
I have a decent implementation of exec/enter/exit/call now, I think.

Trying to think of the issues that slowed me down, one obvious thing in
hindsight is the GNU assembler's violation of the law of least surprise.

My expectation was that "jmp r" where r is a register containing the
address to jump to should "just work". I found the hard way that the PDP11
GNU assembler expects this to be "jmp (r)" but since there was no error
either way, I had to spend some time looking at various docs to figure out
what was going on. Once past exec, enter/exit was the next gauntlet. I had
an idea of using JSR to do the call/return linkage and that panned out well
because all of the complex link chaining is automatically handled by the CPU.

Here also, the elegance of the PDP11 in the flexibility of JSR linkage shines
through. Looking at the history of PDP11 and Forth on wikipedia, it looks
like both are of about the same vintage (late 60's) and they seem to be a
perfect fit for each other.

15 Dec '22
----------
I found and fixed a stupid bug that managed to crawl into the code. It was
subtle, asymptomatic, and serious enough to cause memory corruptions and
it turned out to be an unnecessarily long and drawn out debug exercise.

The symptom was that although the simulation ended successfully and the test
passed, I noticed that the address at which the simulation ended was not at
the expected address. On the PDP11, halt's opcode is 0 so if the code goes
off into the weeds and accesses an uninitialized address with content 0, it
will halt right there instead of where it was expected to halt. Since "call"
is a tricky beast to implement, I was being fairly cautious and luckily was
able to catch the problem (although it was asymptomatic since the test itself
succeeds)

After a boatload of debugging using simh and struggling with the stupid
oct (used by simh) <-> hex (used by gas) conversions, I finally figured
out it was due to memory corruption of the instructions in the code area.

The cause of the memory corruption was because the return stack which grows
to low memory was initialized to the end of the code area for primitives
instead of the very tail end of the "rom" and this happened because the
"mem" label was not really at the tail end of code (including rom) but in
the middle of it (since it was defined in code.prims).

So although the debugging/understanding of what was going on took a while,
the fix was trivial: just place "mem" at the very end so it just needed
to be moved from code.prims to forth.S

---

After that bug was fixed, I ran into yet another bug with the same symptoms
- this one turned out to be bug in "call" itself since I was unnecessarily
incrementing the instruction pointer (since I used the x86 code as a template)

With both bugs fixed, the tests pass and emulator reports the halt happening
at the expected/right address, currently at PC: 000420

---

While doing an initial/quick browse of the PDP11 instruction set, I'd seen the
ASL/ASR instructions for shifting bits. Since these could only do 1-bit shifts,
I decided to defer the implementation of the shift operators << and >> until
they were really needed (and loop operations could be fleshed out). That time
has now arrived and my choices are to either implement this in Forth using
loops or do a native implementation (using loops in the assembler)

Since using a Forth loop would have less performance than native loops, I
decided to use assembly code and the initial implementation looked like this:
	<<     : nip ; 1: ; asl nos ; sob tos, 1b ; t_n ;
	>>     : nip ; 1: ; asr nos ; sob tos, 1b ; t_n ;
But reading through the PDP11 docs again, I noticed yet another opcode: ASH
which can be do multiple bit shifts. So the final implementation uses that.

Which means I could have saved all of the effort that went into the commit
titled "Move the shift operators to a later step". In any case, I assume
there will be microcontrollers that can only do 1-bit shifts so I hope all
this work was not a complete waste of effort and might come in handy later.

16 Dec '22
----------
As of the last commit from yesterday, the PDP11 Forth runtime can be considered
complete so I've included the PDP11 under the "allsteps" regression step in
the toplevel makefile.

---

Comparing sizes with the x86 port, without the tests compiled in, the PDP11
binary weighs in at 422 bytes (including initialization) where x86 needs 338
bytes. The additional overhead is partly because of using 2 byte offsets and
also the fact that x86 byte opcodes can be a tiny bit more compact than the
PDP11 opcodes which need atleast 2 bytes.

The PDP11 binary with all of the tests and initialization code clocks in at
1828 bytes compared to 1236 bytes for the x86 binary. Most of this difference
boils down to the fact that I chose to uniformly use 2 bytes for all Forth
words instead of the hybrid scheme on x86 which uses 1 byte for primitives and
3 byte calls for defined words.

---

The part I like best about this port is that code.prims has been whittled
down to just 60 lines of code. So if we use Fred Brooks' productivity metric
of ~10 lines of debugged code per day, for a "regular" programmer, I'll
guesstimate that a new Forth port can be completed in about a week (or two),
assuming a decent architecture like the PDP11.

---

So, where to next? I think I have a couple of choices:
1. Shrink wrap the x86 and x86-as code.prims just as I did for the PDP11
	- $TECHDEBT, nah!
2. Start off on a new port to one of the architectures listed in PORTING
	- Just completed one, nah!
3. Use the runtime I already have to create a Forth REPL for the PDP11 (or x86)

I think I like option 3 best so that's what I'll be spending some time on next.

18 Dec '22
----------
I've decided to go ahead with the REPL implementation to see how well it fares.

The "real" Forth REPL needs to read in "tokens" (which are defined as any
sequence of non-whitespace characters) and look them up in a "dictionary" and
either run the code (if it is found in the dictionary) or attempt to turn it
into a "literal" number (if it is composed of numeric characters).
If it doesn't match either of those categories the REPL could report an error.

As usual, I'll start off with small changes that I can test easily. So to begin
with, the only thing that the REPL does is read a "token" from the input. This
functionality is called "parse" in some of the Forth implementations that I
looked at so I'll stick to that convention.

Most implementations also use an input buffer to hold the bytes but since it
can be done in a single pass, I'll use the unallocated area for that purpose so
that the memory layout doesn't have to be fragmented into even more segments.
So this breaks with the usual Forth convention of needing words such as TIB
#TIB >IN etc but I prefer the simplicity of what I've done and hope that it
doesn't turn out to be too simplistic.

Looking ahead and planning for ports to other processors, it makes sense to
continue with the "step"wise addition of functionality that I've been using so
far. So the changes that I've made so far have been ifdef'ed under step 39.

To sanity test the implementation, the length of the token that was read is
verified and in addition, it checks the returned location where the string is
stored and also verifies the start and end bytes of the token that was read.

Testing these changes showed that it worked on x86 but failed in a weird way on
the PDP11 simh emulator despite the fact that the changes tested were identical
in both cases. Before lugging out the big guns for debugging the PDP11 issue, I
had a gut feel that the return stack was overflowing and based on that hunch I
bumped up the return stack size and luckily enough that fixed the problem.

Rationalizing about this later, it is obvious that the x86 version was not
affected since the return stack grows to higher addresses (which is currently
unused) whereas on the PDP11 the return stack grows to lower addresses (ie
toward the code area) and any stack overflow will result in overwriting and
corrupting the code area resulting in the weird errors that were observed.

Looking at the emulator output (for the x86) does show that the return stack
size had reached its configured limit. So, for the "real" fix, I've doubled
the configured stack size for the return stack on both the x86 and the PDP11.

It was just dumb luck that the problem was diagnosed fairly easily and I'm
glad this turned out to be an easy fix rather than yet another long drawn out
nightmare debug/redesign exercise.

19 Dec '22
----------
Continuing with the exercise of incrementally adding functionality to the REPL,
at this step (step==40), I've added support for turning a numeric string (read
by "parse" from the input stream) into the equivalent integer when the "state"
variable is non-zero (ie in "interpret"ing state). I've named the word that
does this "atoi" after the C library function that does the same thing.

20 Dec '22
----------
I'm starting to work on adding a dictionary and that brings up a philosophical
question: How much Forth do you really need?

Adding the dictionary manipulation routines (which in conventional Forth are
typically named "create" and "find") requires that the existing "primitive"
words and "defined" words will now need additional space to store their
"metadata" with the dictionary name and header in addition to the "data" (with
just the executable code). This additional requirement for ROM/RAM may exceed
the hardware capabilities that a really "small" microcontroller may have.

The most "minimal Forth" might be one which has just the data stack in RAM
and a bunch of primitives saved in ROM with all of the heavy lifting done
via "metacompilation" performed on the "umblical host". This can easily run
on boards with just a few bytes of RAM and very little ROM (say, less than
about 256 bytes of ROM, if we use something like the single byte offset
scheme that I used in the original x86 implementation).

The next step up might be to add a return stack which increases the RAM
requirements by a bit. Assuming N levels of nesting with 16-bit return
addresses requires N*2 bytes of additional RAM. For example, 4 levels of
call nesting and 4 data stack elements can easily fit within 16 bytes of RAM.

With a larger ROM, it may be possible to have a "static dictionary" stored on
the target (rather than on the host). This allows us to have something close to
a regular interactive Forth except the ability to add new definitions and we
are getting closer to the eventual goal of getting rid of the "metacompilation"
step. I assume that a 512 to 1KB ROM might be sufficient for such a standalone
Forth implementation which can support "find" but not "create" since supporting
"dynamic" dictionary additions enforces the requirement for a larger RAM.

Finally, with an even larger RAM, say 512 bytes or more, it will be possible
to have an "extensible dictionary" which can be used to define new words
residing on the target (with, say, 64 bytes reserved for data+return stack)
and have a completely standalone Forth target which can dispense with the
"umblical hosted metacompilation".

Thus we can see that there are effectively 4 "levels" of Forth needed.
For lack of better names, I'll refer to these "levels" as:
1/4 : "oneforth" (pun intended), which has only primitives and a data stack
      ROM : ~256 bytes, RAM : in the single digit byte range?
2/4 : "twoforth" which has definitions and a return stack (in addition to
      the primitives and data stack that "oneforth" has)
      ROM : ~256 bytes, RAM : 16 bytes (or thereabouts in two digit byte range)
3/4 : "threeforth" which has a static dictionary (in addition to the primitives
      and definitions and the two stacks that "twoforth" has)
      ROM : ~512 bytes, RAM : 16 bytes (or thereabouts in two digit byte range)
4/4 : a full fledged "fourforth"/full/regular Forth with a dynamic dictionary
      in addition to the rest of the bells and whistles from "threeforth".
      ROM : ~1024 bytes, RAM : 512 bytes or more - to hold the dictionary

So the answer to my earlier question: How much Forth do you really need?
is "it depends" so my response is to provide 4 options in the makefile
(as named above) and let the user who is stuck with a specific choice of
microprocessor decide how much Forth they really need.

Since microcontrollers come in various sizes, I'll also need to think of a
"shrink to fit" capability rather than the current incremental "step" wise
implementation such that only the closure of the set of all words required
from rom.4th gets pulled into the final ROM image.

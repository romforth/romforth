INDEX
-----
	* 11 Nov '22
	* 13 Nov '22
	* 15 Nov '22
	* 18 Nov '22
	* 30 Nov '22
	* 01 Dec '22
	* 03 Dec '22
	* 05 Dec '22
	* 06 Dec '22
	* 07 Dec '22
	* 08 Dec '22
	* 09 Dec '22
	* 12 Dec '22
	* 15 Dec '22
	* 16 Dec '22
	* 18 Dec '22
	* 19 Dec '22
	* 20 Dec '22
	* 22 Dec '22
	* 23 Dec '22
	* 06 Jan '23
	* 07 Jan '23
	* 08 Jan '23
	* 10 Jan '23
	* 11 Jan '23
	* 12 Jan '23
	* 13 Jan '23
	* 14 Jan '23
	* 16 Jan '23
	* 17 Jan '23
	* 18 Jan '23
	* 23 Jan '23

11 Nov '22
----------
The difficulty I'm running into now with the C port is that it is turning into
what appears to be a long drawn out struggle between C and Forth to figure out
who has first dibs on access to the system.

Forth obviously considers the entire machine as personal property unto itself,
to treat as it wishes. For example, Forth needs access to the return stack but
modifying the return stack in C looks like a fairly heavyweight operation using
getcontext/setcontext or other lower level alternatives using "asm"

There is also clearly an impedance mismatch between Forth's view of memory and
the memory abstraction that C provides - especially since the Forth bit'ness
of this implementation by design is 16 bits vs whatever processor bit width it
happens to be on the system that the C compiler is running on.

Rather than go into contortions trying to make the two world views conform to
fit each other, I'll call this port to C complete, for the most part, since new
Forth definitions can be added to defs.4th (although clipping its wings like
this makes for a very crippled/powerless Forth implementation).

So it does look like there is a real need for direct access to the CPU to have
Forth's power shine forth, so I think I'll go back to the original roadmap and
pick up things back up from where I left off, looking at what port to do next.

13 Nov '22
----------
Rather than jump directly into selecting a processor for the next round of the
porting exercise, I decided to take a step back to look at where I could be
more productive and not waste time on repetitive grunt work.

So now that I've done the porting exercise a couple of times, one thing that
I've found which appears to be a serious waste of time is starting over from
scratch for each port with an empty rom.4th and then adding the same generic
code over and over again after each step as the port progresses. For example,
the rom.4th changes to verify the key/emit functionality was done in commit
589f315d74e90e3e097112dc8760b41cdf958a22 at the time of the initial bootstrap.
At the time of "porting" this change to GNU "as", the same set of changes was
done in rom.4th at commit 2eba44f4643e42c98b8cf654c3936a333a4e225d. This was
repeated yet again at the time of the C port, when the exact same set of
changes to rom.4th was made in commit 07c25aaf30e1a7dc0a566adc086e3d0a3f896519

So rather than repeat this for each port, it makes sense to abstract out
the generic code in rom.4th and delimit each step of the porting process
within that file so that we can increase a "step" variable after each step
of the porting process so that when all the "steps" are complete, and all the
tests run successfully, we can declare that port complete.

This removes all of the duplicated effort that goes into keeping the tests
(which are part of rom.4th) in sync with each of the porting steps. Instead
of that approach, the new process ensures that the rom.4th contents remain
the same for all ports and the only thing that changes is the "step" variable
(which in some sense denotes the progress of a specific port).

Only time will tell if this "premature standardization" is a good thing or not.

As part of this process, I've also decided to add yet another primitive and
sneak it into the rom.4th "standard" as part of this overhaul. The primary
reason to add it in is for symmetry with "pick". For lack of a better name,
I'm calling it "stick" and like "pick", which gets an element from the stack,
"stick" replaces an element in the stack with a new value.

To parameterize individual ports, I've added a provision for Perl/shell-like
"dollar" variables. Since the code processor does not yet exist, I've not
modified the existing rom.4th files but created the new/generic version at
the top level. As this gets fleshed out and tested, the other rom.4th files
will be eventually obsoleted and removed.

---

That's it for the technical part of this journal entry. On a personal note,
as of today, it is 13 years since Lisa died. She would have been just the age
at which I was getting into the swing of all things related to coding. I wonder
if she would have chosen to be a coder like me.

Anyway, miss you Lisamma.

15 Nov '22
----------
I'm yet again at the crossroads of choosing a processor to work on next and as
with the earlier choice that was made, of fleshing out the generic test code in
rom.4th first, I've chosen to again start off by writing up what amounts to an
elaborate and generic how-to/"process document" on how to go about the porting
exercise for any given processor. It is meant to match up with the "step"s in
the rom.4th test cases although there isn't an exact 1-1 correspondence since
this "code" is meant to be more for human consumption than for direct use by
machine.

This is also an attempt to consolidate the things I've learnt from the previous
round of porting exercises that have been completed so far and the expectation
is that this "code" will continue to be updated with newer ideas as I work on
additional ports for other CPUs.

Since it is written for a "generic" CPU, I've placed it under pseudo/code since
much of the "code", if you want to call it that, is a mishmash of C and Forth
along with some non-C like notation for auto increment/decrement borrowed from
6809 assembly code. Although it is pseudo-code I've written it in a way such
that it may be possible to write a parser for it and turn it into machine code.

18 Nov '22
----------
This is starting to become a pattern now I guess: everytime I think I should
start on a new port, the overhang of the previous work takes me off on yet
another tangent. In this case it is an attempt to make sure that the new
version of the tests in rom.4th can actually work seamlessly with the original
code. The newer version of rom.4th had some changes from the version in the
port directories so I assume it is wise to test stuff out now on known code
rather than figure things out the hard way on unknown code where I'm wrangling
a new CPU and new toolchain along with the newer tests. It will also prove
if this strategy was a good choice to begin with.

30 Nov '22
----------
I think the x86 port is now complete (yes, really, at least to my satisfaction)
now that the last of the annoying little techdebt details are cleared. So I can
declare unambiguosly that it is now time to start on the next port.

In the initial list of architectures that I had listed in the PORTING doc, I
realized that I missed a truly important one: the PDP11 (I've updated it there
now). In my early student days, we covered the PDP11 as part of the course on
"Computer Organization" based on the textbook of the same name authored by
V. Carl Hamacher, Zvonko G. Vranesic and Safwat G. Zaky.

---

A small personal anecdote about this book : I bought this book long, long ago
when I was a student (when it, quite literally, cost a fortune). From the
scribbles on the back of the book, it looks like the price was $7.95 (USD? or
more likely Singapore Dollar, since it is the "International Student Edition"
printed in Singapore) and it was sold for the princely sum of Indian Rs 125/-
which in my student days would probably have been about ~2-4 months worth of
lunch money. This was in the late 80's so I'm really dating myself here. I'm
really grateful that my Dad (Happy Birthday, Apai!) and Mom plunked down their
hard earned money to buy this book for me.

Thank you Apai & Mom! :heart: :RIP:

---

Switching back to the technical discussion, the pseudo code (in pseudo/code)
that I wrote to help with the porting reminded me of how well attuned the PDP11
instructions are to the programmers needs from an assembly coding point of view

I'll assume that the instruction sets of the 68000 and the MSP430, both of
which are elegant in their own ways, all trace their lineage back to this
beautifully crafted, gem of an ISA. Obviously, I can only talk about what I
know, so in case the PDP11 inherited its elegance from an earlier design, then
hey, here's a shout out to them too.

Some research into how to emulate a PDP11 and cross-compile/build for it led me
to: https://ancientbits.blogspot.com/2012/07/programming-barebones-pdp11.html
which walks through all of the steps required to do this in excellent detail.

The quick summary/cheatsheet is:
- Build/install binutils (for pdp11-aout-as and pdp11-aout-ld)
- Build/install simh to emulate the PDP11
- Build bin2load from https://github.com/jguillaumes/retroutils
  This utility is used to modify the a.out binary generated by the pdp11 as/ld
  into a "lda" binary which can be load'ed directly by simh during emulation.

Using these instructions I was able to successfully complete the "Preamble"
step of porting documented in pseudo/code for the PDP11 port.

01 Dec '22
----------
Starting at step 0 of the porting work for PDP11 brought me back to yet another
round of thinking about the format of code.prims. So far, I've used the
	code{ ... }code, inner{ ... }inner and fallthru
among other directives for the assembly language primitives of the x86 ports
but looking back at it now, I find all of that a bit too verbose compared to
the spareness of Forth's own : ... ; notation. So as an experiment, I'm going
to try doing an exercise in extreme minimalism: what if assembly code did not
use any type of decoration whatsoever?

So the plan is that assembly code will be written in code.prims in the format:
	forthlabel : assembly-line1 ; assembly-line2 ; ... ;
all on one line to improve the "code density". The "forthlabel" is just the
conventional forth word name and the assembly code delimited by the semicolons
implement that word.

Since this will be preprocessed by the genprims script anyway, I'm thinking of
putting a spin on it though, where ';' will serve multiple purposes which
hopefully won't cause me too much confusion down the line.

As mentioned above, the ';' serves to delimit independent assembly code lines
but the new spin on it is that it also serves to denote calling "next" if it
is the terminating character on a line. If the line is not terminated by a
semicolon, the expectation is that the code will fall through to the next line
of code below it. So code blocks that currently looks like this:

	code{
	foo bar
		line1
		line2
		...
	}code

will turn into this:

	foo : line1 ; line2 ; ...

Note that the assembly label "bar" in the original code is no longer needed
since it will be auto-generated by the genprims script. In the initial x86
port, "bar" was usually a copy of "foo" if "foo" was alphanumeric (for example
"emit emit") or an alphanumeric replacement (for example "@ fetch"). I've
tried to semi-automate this by using the forth label if it is alphanumeric.

Similarly, inner{ ... }inner code blocks that currently looks like this:

	inner{
	foo bar
		line1
		line2
		...
	}inner

will turn into this:

	foo : line1 ; line2 ; ... ;

Note the addition of the terminating ';' in case of "inner" blocks which is
meant to denote adding the implicit call to "next".

Code blocks that needed "fallthru" can also be denoted in the new scheme just
by leaving out the terminating semicolon. Hopefully, this will make for a much
shorter and crisper implementation.

Although the purpose of the overall project is to showcase a really small Forth
implementation, simh/PDP11 provides me 64K of RAM which is such a luxury that
I'm going on a splurge and use an entire 16 bits for each word offset. This is
a code size win even for jsr calls so I'm not going to go into contortions to
reduce the offset down to 8 bits - although that should be fairly easy as well.

03 Dec '22
----------
Getting output to the console working under simh was not too much of a hassle
since I was continuing to follow the really helpful notes at
https://ancientbits.blogspot.com/2012/07/programming-barebones-pdp11.html

I did simplify the code, a lot, though, based on the sample code from the
"PDP11 Peripherals and Interfacing Handbook", an online copy of which is
available from:
http://www.bitsavers.org/pdf/dec/pdp11/handbooks/PDP11_PeripheralsHbk_1972.pdf

Although I initially used the console device for output, one difficulty I ran
into with using it was with trying to redirect that output to a named file. In
the end, I decided that the struggle was not worth it and just decided to use
a different device (the line printer, LPT/LP11) since simh allows it to be
directly attach'ed to a named file.

Next, I just need to do the same thing for console input as well. Let's see
how long figuring that one out takes.

05 Dec '22
----------
Sometimes it is the simplest things that take the longest to get done. It turns
out the premonition I had about redirecting the input from a file as mentioned
in my previous journal entry turned out to be fairly spot on.

My first attempt at implementing "key" was to use the console device and it
worked without much debugging - using the sample code from Digital in the
"PDP11 Peripherals and Interfacing Handbook" available from:
http://www.bitsavers.org/pdf/dec/pdp11/handbooks/PDP11_PeripheralsHbk_1972.pdf
came in pretty handy again.

Since I want to be able to automate the testing though, the next attempt was
to redirect the input from a file. I initially tried to use the same approach
that succeeded for me with "emit" (where I used the LPT device instead of the
DL11 console output). I thought I could attach the "Paper Tape Reader"/PC11/ptr
device to the input file and change the addresses from 017756X to 017755X and
call it a day. But for some unknown reason I haven't been able to get that
working so far. Running ex'amine on the device shows that the data exists as
expected but the code kept looping as if the data wasn't available. Rather than
spend even more time on trying to fix whatever was broken, I decided to read
through the simh docs to see if there was another device I could test instead
but happened to see the "send" command that allows you to inject data into the
console input. So for now, I've decided to use that feature as a workaround.

Given the time I've spent trying to get this working on simh, I now wonder if
it wouldn't have been faster to just write yet another emulator for the pdp11
just like I did for the x86. Perhaps, if I get stuck again, that's just what
I'll do.

06 Dec '22
----------
For implementing the data stack on the PDP11, there is a literal profusion of
choices since any of the PDP11 registers can be used as the data stack pointer
(given the PDP11's flexible addressing modes).

Since I want to see if the native/machine stack can be used for the return
stack, I'll choose the next available register (r2), rather than r6 as the
data stack pointer. The current register mapping is: R0: IP, R1: TOS, R2: SP

The remaining decision is about where to place the data stack. I'll make the
same choice that I made on the x86 port, which is to have it grow to low memory
starting from the beginning of the text area. So the current memory layout
looks like this:

			0x100 -> higher memory
	  ------------------------------
	   <- data stack | code/text ->
	  ------------------------------

07 Dec '22
----------
During the x86 port, I chose to use the macro features of the x86 assembler
to do all of the macro expansions that were needed when a Forth word used a
"lower" level forth word. For the PDP11 port though, I want to try something
different and have most of those expansions done by genrom instead. This seems
to be a cleaner approach than the ugliness of the x86 version where I have
to disambiguate between the macro expansion and a regular call by using '_' to
prefix the words that needed to be expanded.

So this required a little bit of addition to genrom's capabilities.

In the x86 port, I was using 8 bit offsets so all of the addresses were stored
as offsets from the base of the text area. Since I'm using the full 16 bits
for the PDP11 port, I can store the addresses as is.

08 Dec '22
----------
While working my way through "step 5" to implement conditionals on the PDP11
I decided that the scope of this step is too large and needs to be broken up
into smaller steps which are finer grained and more easily tested.

I also found that using "jmp" as a label seems to cause a hiccup for the
PDP11 assembler so it needs to be renamed to something other than "jmp".
I'll pick "j" as the replacement name, for now.

So, my solution to address these issues is to separate out the support for
implementing the primitives "j/jz/jnz" into 3 sub-steps which I'm calling
steps 4.1, 4.2 and 4.3 and then follow that up with the implementation for
"if{ ... }else{ ... }if" in genrom (which remains the same as before) as
part of the original "step 5".

I chose to use the floating point notation for the newer steps since it
allows me to not have to redo the numbering for all of the the other later
steps, thus keeping those step numbers the same, just in case they are
referred elsewhere.

Since it is quite useful to be able to test each of the basic "j/jz/jnz"
primitives independently of the language support (which is only added later
in "step 5"), some standalone/newer tests for these steps have been added
to rom.4th as well. This change then snowballed into requiring changes to
test.inp and test.expected as well. So while I was there I decided to clean
up the conditions used for the earlier tests from "step>N-1" to "step>=N"
which makes it easier to match up each test with the corresponding "step"
during coding and testing.

Since more granular steps are being added, I decided it is safer to test
it all out on the x86 ports first before trying it out on the PDP11 port.

One addition that I've made to the genrom feature set is the ability to
use "immediate offsets" which are different from the "immediate literals".
The "literals" are the usual Forth literals prefixed with the lit operator
and can be denoted as bare numbers/variables or prefixed with the $ notation.

The "offsets" are new and are used for encoding JUMP offsets which don't
need to be prefixed with 'lit' - they are denoted using a '#' prefix.

09 Dec '22
----------
Today was a fairly productive day as I cranked away at most of the easy
parts of the port. The next set of primitives are the hard ones since they
usually require you to pay attention to a lot of detail. I did start off
thinking about how to implement exec/enter/exit/call and have some ideas
about tying it to the PDP11 JSR instruction but that needs me to use the R6
register instead of the R4 register which is used currently.

I'm tired now though and I think all of that can wait for another day.

12 Dec '22
----------
I have a decent implementation of exec/enter/exit/call now, I think.

Trying to think of the issues that slowed me down, one obvious thing in
hindsight is the GNU assembler's violation of the law of least surprise.

My expectation was that "jmp r" where r is a register containing the
address to jump to should "just work". I found the hard way that the PDP11
GNU assembler expects this to be "jmp (r)" but since there was no error
either way, I had to spend some time looking at various docs to figure out
what was going on. Once past exec, enter/exit was the next gauntlet. I had
an idea of using JSR to do the call/return linkage and that panned out well
because all of the complex link chaining is automatically handled by the CPU.

Here also, the elegance of the PDP11 in the flexibility of JSR linkage shines
through. Looking at the history of PDP11 and Forth on wikipedia, it looks
like both are of about the same vintage (late 60's) and they seem to be a
perfect fit for each other.

15 Dec '22
----------
I found and fixed a stupid bug that managed to crawl into the code. It was
subtle, asymptomatic, and serious enough to cause memory corruptions and
it turned out to be an unnecessarily long and drawn out debug exercise.

The symptom was that although the simulation ended successfully and the test
passed, I noticed that the address at which the simulation ended was not at
the expected address. On the PDP11, halt's opcode is 0 so if the code goes
off into the weeds and accesses an uninitialized address with content 0, it
will halt right there instead of where it was expected to halt. Since "call"
is a tricky beast to implement, I was being fairly cautious and luckily was
able to catch the problem (although it was asymptomatic since the test itself
succeeds)

After a boatload of debugging using simh and struggling with the stupid
oct (used by simh) <-> hex (used by gas) conversions, I finally figured
out it was due to memory corruption of the instructions in the code area.

The cause of the memory corruption was because the return stack which grows
to low memory was initialized to the end of the code area for primitives
instead of the very tail end of the "rom" and this happened because the
"mem" label was not really at the tail end of code (including rom) but in
the middle of it (since it was defined in code.prims).

So although the debugging/understanding of what was going on took a while,
the fix was trivial: just place "mem" at the very end so it just needed
to be moved from code.prims to forth.S

---

After that bug was fixed, I ran into yet another bug with the same symptoms
- this one turned out to be bug in "call" itself since I was unnecessarily
incrementing the instruction pointer (since I used the x86 code as a template)

With both bugs fixed, the tests pass and emulator reports the halt happening
at the expected/right address, currently at PC: 000420

---

While doing an initial/quick browse of the PDP11 instruction set, I'd seen the
ASL/ASR instructions for shifting bits. Since these could only do 1-bit shifts,
I decided to defer the implementation of the shift operators << and >> until
they were really needed (and loop operations could be fleshed out). That time
has now arrived and my choices are to either implement this in Forth using
loops or do a native implementation (using loops in the assembler)

Since using a Forth loop would have less performance than native loops, I
decided to use assembly code and the initial implementation looked like this:
	<<     : nip ; 1: ; asl nos ; sob tos, 1b ; t_n ;
	>>     : nip ; 1: ; asr nos ; sob tos, 1b ; t_n ;
But reading through the PDP11 docs again, I noticed yet another opcode: ASH
which can be do multiple bit shifts. So the final implementation uses that.

Which means I could have saved all of the effort that went into the commit
titled "Move the shift operators to a later step". In any case, I assume
there will be microcontrollers that can only do 1-bit shifts so I hope all
this work was not a complete waste of effort and might come in handy later.

16 Dec '22
----------
As of the last commit from yesterday, the PDP11 Forth runtime can be considered
complete so I've included the PDP11 under the "allsteps" regression step in
the toplevel makefile.

---

Comparing sizes with the x86 port, without the tests compiled in, the PDP11
binary weighs in at 422 bytes (including initialization) where x86 needs 338
bytes. The additional overhead is partly because of using 2 byte offsets and
also the fact that x86 byte opcodes can be a tiny bit more compact than the
PDP11 opcodes which need atleast 2 bytes.

The PDP11 binary with all of the tests and initialization code clocks in at
1828 bytes compared to 1236 bytes for the x86 binary. Most of this difference
boils down to the fact that I chose to uniformly use 2 bytes for all Forth
words instead of the hybrid scheme on x86 which uses 1 byte for primitives and
3 byte calls for defined words.

---

The part I like best about this port is that code.prims has been whittled
down to just 60 lines of code. So if we use Fred Brooks' productivity metric
of ~10 lines of debugged code per day, for a "regular" programmer, I'll
guesstimate that a new Forth port can be completed in about a week (or two),
assuming a decent architecture like the PDP11.

---

So, where to next? I think I have a couple of choices:
1. Shrink wrap the x86 and x86-as code.prims just as I did for the PDP11
	- $TECHDEBT, nah!
2. Start off on a new port to one of the architectures listed in PORTING
	- Just completed one, nah!
3. Use the runtime I already have to create a Forth REPL for the PDP11 (or x86)

I think I like option 3 best so that's what I'll be spending some time on next.

18 Dec '22
----------
I've decided to go ahead with the REPL implementation to see how well it fares.

The "real" Forth REPL needs to read in "tokens" (which are defined as any
sequence of non-whitespace characters) and look them up in a "dictionary" and
either run the code (if it is found in the dictionary) or attempt to turn it
into a "literal" number (if it is composed of numeric characters).
If it doesn't match either of those categories the REPL could report an error.

As usual, I'll start off with small changes that I can test easily. So to begin
with, the only thing that the REPL does is read a "token" from the input. This
functionality is called "parse" in some of the Forth implementations that I
looked at so I'll stick to that convention.

Most implementations also use an input buffer to hold the bytes but since it
can be done in a single pass, I'll use the unallocated area for that purpose so
that the memory layout doesn't have to be fragmented into even more segments.
So this breaks with the usual Forth convention of needing words such as TIB
#TIB >IN etc but I prefer the simplicity of what I've done and hope that it
doesn't turn out to be too simplistic.

Looking ahead and planning for ports to other processors, it makes sense to
continue with the "step"wise addition of functionality that I've been using so
far. So the changes that I've made so far have been ifdef'ed under step 39.

To sanity test the implementation, the length of the token that was read is
verified and in addition, it checks the returned location where the string is
stored and also verifies the start and end bytes of the token that was read.

Testing these changes showed that it worked on x86 but failed in a weird way on
the PDP11 simh emulator despite the fact that the changes tested were identical
in both cases. Before lugging out the big guns for debugging the PDP11 issue, I
had a gut feel that the return stack was overflowing and based on that hunch I
bumped up the return stack size and luckily enough that fixed the problem.

Rationalizing about this later, it is obvious that the x86 version was not
affected since the return stack grows to higher addresses (which is currently
unused) whereas on the PDP11 the return stack grows to lower addresses (ie
toward the code area) and any stack overflow will result in overwriting and
corrupting the code area resulting in the weird errors that were observed.

Looking at the emulator output (for the x86) does show that the return stack
size had reached its configured limit. So, for the "real" fix, I've doubled
the configured stack size for the return stack on both the x86 and the PDP11.

It was just dumb luck that the problem was diagnosed fairly easily and I'm
glad this turned out to be an easy fix rather than yet another long drawn out
nightmare debug/redesign exercise.

19 Dec '22
----------
Continuing with the exercise of incrementally adding functionality to the REPL,
at this step (step==40), I've added support for turning a numeric string (read
by "parse" from the input stream) into the equivalent integer when the "state"
variable is non-zero (ie in "interpret"ing state). I've named the word that
does this "atoi" after the C library function that does the same thing.

20 Dec '22
----------
I'm starting to work on adding a dictionary and that brings up a philosophical
question: How much Forth do you really need?

Adding the dictionary manipulation routines (which in conventional Forth are
typically named "create" and "find") requires that the existing "primitive"
words and "defined" words will now need additional space to store their
"metadata" with the dictionary name and header in addition to the "data" (with
just the executable code). This additional requirement for ROM/RAM may exceed
the hardware capabilities that a really "small" microcontroller may have.

The most "minimal Forth" might be one which has just the data stack in RAM
and a bunch of primitives saved in ROM with all of the heavy lifting done
via "metacompilation" performed on the "umblical host". This can easily run
on boards with just a few bytes of RAM and very little ROM (say, less than
about 256 bytes of ROM, if we use something like the single byte offset
scheme that I used in the original x86 implementation).

The next step up might be to add a return stack which increases the RAM
requirements by a bit. Assuming N levels of nesting with 16-bit return
addresses requires N*2 bytes of additional RAM. For example, 4 levels of
call nesting and 4 data stack elements can easily fit within 16 bytes of RAM.

With a larger ROM, it may be possible to have a "static dictionary" stored on
the target (rather than on the host). This allows us to have something close to
a regular interactive Forth except the ability to add new definitions and we
are getting closer to the eventual goal of getting rid of the "metacompilation"
step. I assume that a 512 to 1KB ROM might be sufficient for such a standalone
Forth implementation which can support "find" but not "create" since supporting
"dynamic" dictionary additions enforces the requirement for a larger RAM.

Finally, with an even larger RAM, say 512 bytes or more, it will be possible
to have an "extensible dictionary" which can be used to define new words
residing on the target (with, say, 64 bytes reserved for data+return stack)
and have a completely standalone Forth target which can dispense with the
"umblical hosted metacompilation".

Thus we can see that there are effectively 4 "levels" of Forth needed.
For lack of better names, I'll refer to these "levels" as:
1/4 : "oneforth" (pun intended), which has only primitives and a data stack
      ROM : ~256 bytes, RAM : in the single digit byte range?
2/4 : "twoforth" which has definitions and a return stack (in addition to
      the primitives and data stack that "oneforth" has)
      ROM : ~256 bytes, RAM : 16 bytes (or thereabouts in two digit byte range)
3/4 : "threeforth" which has a static dictionary (in addition to the primitives
      and definitions and the two stacks that "twoforth" has)
      ROM : ~512 bytes, RAM : 16 bytes (or thereabouts in two digit byte range)
4/4 : a full fledged "fourforth"/full/regular Forth with a dynamic dictionary
      in addition to the rest of the bells and whistles from "threeforth".
      ROM : ~1024 bytes, RAM : 512 bytes or more - to hold the dictionary

So the answer to my earlier question: How much Forth do you really need?
is "it depends" so my response is to provide 4 options in the makefile
(as named above) and let the user who is stuck with a specific choice of
microprocessor decide how much Forth they really need.

Since microcontrollers come in various sizes, I'll also need to think of a
"shrink to fit" capability rather than the current incremental "step" wise
implementation such that only the closure of the set of all words required
from rom.4th gets pulled into the final ROM image.

22 Dec '22
----------
This entry is just a documentation of the debug exercise I went through, to fix
a bug, that cropped up while adding dictionary headers to all the "words".

I'm documenting it here simply as a reminder from "current me" to "future me"
in case other issues like this pop up on other architectures, as part of any
future porting exercises, by which time I expect I'll probably have forgotten
many of the more intricate parts of the plumbing. My hope is that this
documentation will help with making those debug exercises faster/smoother or at
least more productive.

Ok, so lets start with the problem. I'd made some code changes, primarily to
the script (genprims) that turns code.prims to assembly to generate dictionary
headers for each of those primitives. Testing it was resulting in a failure
only when the dictionary headers are generated, whereas things work as expected
when the headers are not generated. With the dictionary headers in place, I was
getting the following error from the pdp11/simh emulator:
	Trap stack push abort, PC: 000416 (HALT)
Using bc, we can map this octal address to the hex value:
	obase=16
	ibase=8
	000416
	10E
And subtracting 100 from 10E give address 0xE which can be looked up in the
assembly listing file which maps to:
			bye:
	000e	0000		halt
So it appears that it halted as expected, but why does it report that strange
"Trap stack push abort" error message?

Since the "stepfile" approach gives me a means of testing this at small code
change increments, I decided to give that a shot to find the earliest change
that triggers this bug. Running "make allsteps" and waiting for a while until
it fails and then running "head -1 fpp.config" gives me:
	step=22
which shows that the earliest failure is triggered at step 22. I decided to
confirm that things were really working at the previous step by setting the
step value to 21 and rerunning make :
	cd pdp11 ; sed -i 's/step=22/step=21/' fpp.config ; make
This to my surprise showed that that the test actually had failed even at
the earlier step 21 with this error:
	Trap stack push abort, PC: 000612 (JMP @(R0)+)
Unfortunately, this is not reported as a non-zero exit by pdp11/simh so despite
the error, make saw it as success and moved on to the next step.

I could change the makefile to handle anything other than "HALT instruction"
as an error and rerun the whole regression test with "make allsteps" to see if
I can catch this error much earlier. So I went ahead and did that and after the
usual long wait for the regression failure, and using "head -1 fpp.config",
just as before, it turns out the earliest failure actually happens at step 14
and the error is the same as the one that happened at step 21:
	Trap stack push abort, PC: 000612 (JMP @(R0)+)
Again using bc to do the oct->hex conversion:
	obase=16
	ibase=8
	000612
	18A
Subtracting 100 from 18A gives us offset 8A, which maps to the fetch/@
operator (by looking up address 8A in the forth assembly listing):
	96                    lbl007:
	97 0088 4112           mov (r1), r1
	98 008a 5800           jmp @(r0)+
So for context, what is happening is that at step 14, we have added the "here"
variable and we are fetch'ing its value and that for some strange reason fails
when we add the dictionary header (but works fine when there is no header).

Since I'm aware of alignment issues (from the time I worked on SPARC at Sun
Microsystems) the problem is obvious: the addition of the header made the
location of the "here" variable unaligned, so all that is needed to fix this
issue is to add a alignment directive (".align" in the case of binutils) ahead
of variable declarations.

If I was a newbie who was not aware of processor alignment issues, I guess the
next step might have been to trawl through the code in SIMH to figure out
exactly why it reports that error, but in this particular case, that additional
step was not required due to my earlier experience with these types of issues.

If I was a newbie working directly on the hardware and ran into something like
this, I assume it would result in either grey hair or maybe no hair ;)
The hard lesson here might be : always use an emulator - but that can come with
its own share of latent bugs especially if the emulation does not perfectly
match the hardware.

After fixing this alignment issue with variables in the genprims script, I then
decided to run yet another round of "make allsteps" in the hope that I was past
the entire class of such problems but it again ran into the earlier failure at
step 22 (which was the first problem that I had documented above, prior to the
step 14 failure).

Since alignment issues were top of mind for me, and it is at step 22 that the
generated definition for "bl" is used for the first time, it was fairly clear
to me that this issue was also due to not having an alignment directive for the
generated code produced by the genrom script. So that script was also modified
to generate the ".align" directive ahead of definitions as well.

In hindsight, it is clear that like most debugging exercises, cracking it was
a mix of grunt work and dumb luck. The "lucky part" was in observing that step
22 was not the very first failure and tracking the very first failure all the
way back to step 14 where it was easy to figure out the alignment problem. Once
that was out of the way, seeing the new issue again at step 22, and putting 2
and 2 together was a no-brainer. I assume things would have been harder if
these were encountered the other way around (ie in the opposite order).

Anyway, running the "make allsteps" regression step again after making these
two changes resulted in all of the tests passing without any further breakage.
I hope documenting all of this in gory detail now turns out to be useful later.

For now, the addition of the dictionary headers has been done only for the
PDP11 port - which I'll use as the "primary" port going forward. Adding the
dictionary headers to the x86 code is the next step. Since x86 supports
unaligned access, this bug will not be encountered there so I hope that the
addition of the headers to the x86 port goes more smoothly than this.

23 Dec '22
----------
Now that the dictionary support for x86 GNU "as" is done, it is time to look
at repeating it for the x86 nasm port as well. Since the initial bootstrap
implementation was done on x86 nasm, it has a makefile which is different from
that of the other ports. So as part of this exercise, I decided to "demote" it
a bit so it is no longer considered the "primary" port and it is now just "yet
another" port. This change also ensures that all of the makefiles now follow
the same template but getting there needed some major surgery to the x86 and
the x86-as makefiles since the x86-as makefile had some implicit dependencies
on the x86 build. But all of this is technical debt and in preparation for the
new year, I might as well pay it down now rather than later.

So now that the dictionary headers are available for all the current ports, I
plan to take a small break from all this for a week (or two) and just relax
over the holidays so here's to hoping for a refreshed, relaxed and wonderful
New Year.

06 Jan '23
----------
As I was getting ready to add the functionality to "exec" words from the repl,
and thinking about how to code something like "lfa2cfa", I realized that the
align directive used in PDP11 has now turned into a stumbling block since the
runtime does not have any meta data from the build to figure out if a padding
alignment byte was added or not. So the only choice apparent to me is to rework
the dictionary header layout by shuffling the fields around so that the padding
is kept out of the way.

The new header format (which, btw, completely breaks with the traditional Forth
header layout) can be described using the simple ascii diagram layout shown
below where the ^ symbol marks alignment boundaries:
	... | align | pad | nfa:(name ... | count) | lfa | cfa ... |
                    ^                              ^     ^
The layout could also be described more formally using this C'ish pseudo code:

	struct name {
		optional byte alignment[...];
		optional byte pad[...];
		byte name[count];
		byte count;
	};
	struct dict {
		struct name nfa;
		struct dict *lfa;
		byte cfa[...];
	};

The alignment bytes are used only if the previous dictionary entry ended on an
unaligned byte boundary. The pad bytes are used so that the name field always
ends at an aligned byte boundary.

Using this new scheme, it is clear that to get to the nfa from the lfa, we
just subtract the count (and unlike the earlier scheme, the padding and/or
alignment bytes are not in the way). Going from the lfa to the cfa is also
trivial (just add "cell"). The reverse mapping from the cfa to lfa also becomes
trivial (just subtract "cell"). This would have been much harder to do with the
traditional Forth header layout, so, all in all, I think this scheme is a much
better layout than the conventional Forth dictionary header layout.

Since making this change will regress the tests at steps 41, 42 and 43, I've
decided to rollback the step value to 40 and just make the dictionary header
changes after only a manual/visual inspection. I'll add the modified tests back
in at each step progression rather than turn this into one humongous commit.

07 Jan '23
----------
Adding support for exec'ing words from the repl exposed a bug that many of the
words did not have dictionary headers (but only on x86). It turns out that the
generation of the dictionary headers was not being done correctly for many of
the x86 specific code.prims directives. I'll attribute this to the existing
$TECHDEBT that genprims (and genrom) in each of the ports are copy-pasted. At
some point I should consolidate all of them and in addition have a unified
format for code.prims as well. For now though, I've just fixed the bugs in
genprims (in both x86 and x86-as).

08 Jan '23
----------
With the support for exec'ing defined words from the repl, "threeforth" is
in some sense complete since we can now interactively "exec" all the variables,
primitive definitions and Forth definitions which are available as part of the
dictionary. Since two different types of "thread"ing are used in the x86 and
PDP11 ports, I've added a config variable called "THREAD" to distinguish among
them. The x86 version which uses an opcode to prepend the cfa is called thread
type 1 and the PDP11 version which uses a bare cfa is called type 2.

The previous commit added the requirement that the "latest" variable needs to
be the last variable defined in code.prims since it is used as the boundary
between variables and primitives. This commit now adds another such requirement
that the definition of "bl" needs to be the very first Forth definition since
it is used as the boundary between primitive definitions and Forth definitions.

With this commit, all of the words that are already in the dictionary can be
run directly from the repl. As I've previously discussed in the entry dated
20 Dec '22, additional functionality to extend the dictionary is possible by
adding more Forth definitions. Even on relatively low-end microcontrollers, the
ROM tends to be fairly beefy, so this implementation proves that having an
easily portable and interactive version of Forth that can run even on the
lowest end microcontrollers is quite possible.

Currently the PDP11 ROM usage, (without all of the regression tests included),
clocks in at 1550 bytes and the x86 usage weighs in at 1217 bytes. With all
of the regression tests included, the PDP11 needs 3066 bytes and the x86 usage
is 2212 bytes. The "gensize" perl script which is part of this commit was used
to generate these numbers. I've also added this to the makefile so "make size"
should generate these results as well.

The runtime RAM usage can be estimated by running the the x86 emulation. RAM
usage, with all the tests enabled, shows that just a paltry 24 bytes for the
data stack and 12 bytes for the return stack are sufficient. Without the tests,
the usage remains at 4 bytes for data stack and 0 bytes for the return stack.
In addition, the static variables use 6 bytes.

So I'll go ahead and stake a claim that the "threeforth" version of Forth which
can be called interactive, (for some definition of exactly what "interactivity"
means in this context), can easily run even on microcontrollers that have less
than 32 bytes of RAM (if the current set of tests are disabled).

What threeforth cannot do is create new dictionary entries at runtime, which
one may claim is the essence of Forth. So now that threeforth is done, I can
now start on a final/fuller version of Forth (which I had called "fourforth" in
the entry dated 20 Dec '22) which can create dictionary entries and link them
to the older entries in ROM and exec them at run time for "full" interactivity.

10 Jan '23
----------
While working on this set of code changes, I realized my lack of foresight in
not providing something like "#}else{" and "#}elsif{" directives in the "fpp"
script. For now, I have to be very careful with the repeated use of "#{if" and
"#}if" pairs to make sure that these directives don't result in overlaps and
also cover all the cases. Perhaps I should follow Rust's example and enforce
complete coverage for all sum types, while I'm at it ;)

So far, for the Forth comments, I've been following a "structured commenting"
style where '[' stands for the "rest of the data stack" and ']' stands for the
"rest of the return stack" with '|' marking the boundary between them. Input
was denoted using '<' and output using '>' while memory addresses and values
were documented using "(addr:value)" with "//" used for additional clarifying
comments. Now that the dictionary can be modified at runtime, I'll extend that
notation a bit to use '\' to denote the contents of the dictionary.

The commit of the allocation (alloc, alloca) routines which was done yesterday,
marked the start of the implementation of "fourforth". Today I'm getting into
the meat of the implementation with the definition of "create" which "parse"s a
"token" from the input stream and adds it as a dictionary entry. Once this out
of the way, I can start working on the repl to add state handling and provide
a facility to deal with "immediate" words.

11 Jan '23
----------
In Forth, the "state" variable is used to track the transition from "interpret"
state (usually denoted by 0) where all words are exec'uted within the repl to
the "compile" state (usually denoted by 1) where all words are appended to the
latest word that was create'd. The conventional Forth word that does the switch
from 0 to 1 is '[' and the complementary word to switch the other way is ']'.
The state diagram that compactly expresses this is:
	state	event	nextstate
	0	[	1
	1	]	0
Since I've appropriated '[' for commenting purposes, I'm going to rename them
run[ and ]run which calls out the fact that the bracketed code is run even at
compile time. These words are internally used by the Forth "define"ing word ':'
and its complementary pair ';' which is the "immediate" word used to mark the
end of the definition started by ':' which means the above state diagram needs
to be extended a bit as shown below:
	state	event	nextstate
	0	:	1
	0	run[	1
	1	]run	0
	1	;	0

Once "compilation" starts and we assemble a sequence of existing Forth words
into a sequence of cfa's to be exec'uted, we need a means of switching from
"compile" state back to "interpret" state. Rather than hardcode some kind of
a reserved word to do this, "immediate" words count as Chuck Moore's brilliant
solution to do this in Forth. "immediate" words will be exec'uted by the repl
even in "compile" state and this provides a generic escape mechanism to allow
all types of intermediate processing to happen while "compile"ation is still
in progress.

Enabling the addition of "immediate" words to the dictionary now allows me to
code up a full fledged Forth REPL. While "create" enables adding new dictionary
entries, "immediate" allows us to create words that can switch the state. So,
as the next step forward, I'll work on a repl that can take advantage of the
"immediate"ness of words that have been added to the dictionary.

12 Jan '23
----------
This is the first year in which I cannot call either of my parents on their
anniversary. After Dad died in 2020, Mom soldiered on for two years and this
year I'll miss both of them.

Happy 56'th Anniversary Apai and Mom! All of us miss you. :heart:

13 Jan '23
----------
The bulk of the work involved in testing out the code for the all important
Forth words ':' and ';' (which are used to define new words in Forth) was done
as part of the tests in the previous commit at step 50. So in this commit, I've
consolidated those changes into actual definitions. Rather than code up a repl
to use these definitions, I've decided to make the tests at this step call ':'
and ';' explicitly since I'm still thinking through how to make ';' immediate.
---
On a personal note, as of today, it is 3 years since Dad passed away from
cancer (multiple myeloma) at the age of 79. Miss you Apai. :RIP:

14 Jan '23
----------
Since empty definitions were proven to work yesterday, the next step I could
think of was to add support for compiling numbers into the body of definitions.
After making those changes, testing showed some weird behaviour. It worked with
no issues on x86 but consistently got into a hang state on PDP11. I spent some
time going over the code with a fine tooth comb especially the #ifdef'ed parts
and adding some debug prints for troubleshooting to make sure I had not messed
up something related to the PDP11 specific parts since the code is now starting
to be rife with ugly #ifdef's sprinkled helter skelter. Despite all that work,
I didn't make much headway with those debug efforts, until I remembered that I
had observed this kind of failure once before (see the JOURNAL entry dated 18
Dec '22). Based on that I suspected yet another return stack overflow. The x86
emulator reported that the return stack usage was 18 bytes (of the configured
20). This was close enough to the limit that I decided to bump it up to see if
the problem went away and sure enough after increasing it to 30 bytes (on both
architectures), PDP11 also started working without any hitches. Whew!

16 Jan '23
----------
Now that I'm getting to the part where the repl starts to get a bit more
complicated with the addition of immediate words and compilation of defined
words, it was predictable enough that I'd run into weird bugs. But these bugs
were nasty and seemed to literally crawl out of the woodwork. They slowed me
down quite a bit so I think it is worth documenting them here. I'll list them
in the order that I found them:
1. state was not initialized to 0 (it was initialized to 1 for the c@/c! tests)
2. cpl_ex used @ instead of c@ to access the state variable
3. cpl_ex and cpl_ex_imm expected an lfa but were passed a cfa

Bug #1 was a "wrong initialization bug" where the repl code expected to start
with interpreter state==0 but because of the tests (written long long ago,
which predictably enough, I'd forgotten all about), it had been initialized to
1. The fix was to initialize the state variable prior to calling the repl.
So that was a relatively easy bug to fix.

Bug #2 and #3 fall under the category of type bugs. Since Forth does not have
any notion of static typing (or any means of enforcing it), such bugs can
easily sneak in and strike at runtime. Bug #2 was almost a C-like type cast
bug caused by using a byte as an int.

Bug #3 was subtler since an address on the stack just looks like any other
address. The initial coding was done with cpl_ex and cpl_ex_imm expecting an
lfa on the stack. But somewhere along the line, while refactoring stuff, I
changed the repl to send a cfa and forgot to update the called routines. I
think the lack of static typing may rule out using Forth for large projects
unless rigorous attention is paid to handling interface changes such as this.

Or perhaps it's just me being tired and careless.

Anyway, with all of these bugs out of the way, things are finally working. Yay!

---

After all the struggles I went through to get compile time definitions working,
adding variables and primitives turned out to be a walk in the park. So at
step 54, I think I can call the repl functionally complete and fourforth is
done. The rest as they say is just a "small matter of programming".

Looking at the stats generated by the gensize script, x86 needs 3021
bytes total and 1774 bytes without tests while PDP11 needs 4146 total and
without tests it fits in 2280 bytes.

So here's to freedom from the slavery of code bloat (on MLK Day)!

For comparison, here's what C needs:
	echo 'main(){}' > x.c ; make x ; wc -c x #  8544 x
which shows that the generated binary needs 8544 bytes - to do nothing!
And for another example with Rust:
	echo 'fn main(){}' > x.rst ; rustc x.rst ; wc -c x # 3321352 x
which shows the Rust binary needs ~3.3 MB to do nothing although stripping
the binary does bring it down to "only" 297232 bytes. Granted this is using
rustc 1.50.0. Finally, while I'm pointing fingers, let's not leave out Go:
 echo -e 'package main\nfunc main(){}' > x.go;go build x.go;wc -c x # 1101232 x
which shows Go needs no less than ~1.1MB to do nothing and even the stripped
binary needs 737896 bytes. Like the Rust version the Go version I have is also
behind the times (go version go1.6.2), but I don't really believe any newer
versions are going to improve anything. So the "bloat prize", by a wide margin,
should go to Go.

That's enough of a rant (and probably an unfair one at that - I assume all
three languages have good reason to have large binaries). For Go, I assume it
is their runtime and for Rust I think it is probably the standard library. C's
bloat might also be due to the standard library. In any case, on machines with
gigabytes of RAM, none of this bloat really matters.

So I'll continue to chip away at the problem that I'm trying to address for a
really niche and extremely narrow problem space of microcontrollers which are
resource constrained in terms of ROM and RAM (and quite likely, power usage).
So, changing gears to look at next steps, I could start a new port to yet
another such microcontroller architecture. Since the two ports that have been
completed so far have been little-endian, I'm tempted to try a big-endian
architecture for a change to see if that turns up any new portability issues.

SPARC, maybe?

17 Jan '23
----------
Before moving on to doing yet another port to some other processor, I decided
to finish fleshing out the repl a bit more to add support for the conditional
and loop control structures. But before adding even that, the very first thing
I really need is a means of writing comments. The typical implementation of
comments in Forth is trivial - something along the lines of "10 parse 2drop" to
read everything upto the end of the current line and ignore what was read. Oh,
and of course it must be marked "immediate" since it can be used within
definitions. The fact that comments can be added to the language after the fact
without any change to the "original language" is one of the more jaw dropping
features that folks new to Forth often encounter since you run into it sooner
than the fact that loops and conditional structures can also be bolted on to
the "language", in almost the same way, almost as an afterthought.

But before I can go ahead with adding support for comments, I need a more
flexible means of switching between the test code in rom and the repl.
Currently I'm counting words to handle this switch. A more flexible approach is
to use the old "2ret+call" technique to implement a simple semi-coroutine like
mechanism. So that will be the very first thing I'll work on before attempting
to code the rest of the stuff.

---

After trying out a couple of alternatives, rather than use semi-coroutines, I
ended up with a simpler approach which is to just do a multi-level return from
a "longjmp" like word which I've provisionally called "3ret" (since it drops
off the top 3 levels of the return stack, on x86). Calling 3ret from within the
"outer" repl will return control back to the test. During testing, I found that
the PDP11 needed an extra layer of return stack unwinding but I'll leave the
name as is for now since I can't think of something more meaningful currently.

18 Jan '23
----------
Now that I have a reliable means of switching from the repl back to test mode,
I went ahead with adding the code to handle comments (which as I mentioned in
the previous JOURNAL entry, is fairly trivial). Initially I debated with myself
whether adding new definitions should continue to be done in defs.4th or should
be part of the "console input" via rest.inp. For now I've reluctantly decided
to add the definitions to rest.inp (mixed in with the tests) rather than adding
just the definitions to defs.4th since the outer interpreter is the place which
can process "immediate" requests. A different way to solve this might be to
define "immediate:" which take a parameter (just like create) but that also
requires entangling the code with the input stream. Another idea is to
introduce yet another defining word pair (say imm{ ... }imm, just like the
def{ ... }def pair) to declare words which are immediate. Of these choices,
sticking newer definitions into rest.inp seemed easiest. So that's what I've
ended up doing for now.

One side effect of this choice is that the entirety of the code needed for a
"full Forth" implementation is now spread over three different files:
code.prims, defs.4th and now, rest.inp as well instead of being centralized
or available in one "object" such as the assembly listing file (forth_dict.lst)
This also means that an accurate means of getting the ROM/RAM requirements
becomes harder.

I'll assume that the amount of additional new code that will be needed is not
a lot. So I'll forge ahead and revisit this decision if it turns out to be a
major problem down the line. I also have in mind the idea of a "shrink to fit"
tool which can be used at runtime to generate the closure of all dependencies
of any given word. So that might be another alternative way of getting a single
snapshot of all of the required code.

---

One issue that showed up during testing is that comments need the newline
characters to be passed through. The existing code goes out of its way to get
rid of them (for legacy reasons). So I've added some special casing in the
makefiles for rest.inp, to preserve the newlines. I have a special generator
("genrestinp" on PDP11) which sticks the newlines back in (via the simh/"send"
command) and on x86, rest.inp is special cased so that the newlines are not
egregiously removed.

23 Jan '23
----------
This entry is just an attempt at documentating yet another bug that I ran into.
Hopefully the steps I took here will be useful in the future when strange bugs
such as this pop up.

The bug itself was fairly old and was introduced over a month back (on Dec 15)
but I ran into it only now, while it lay in wait biding its time to pounce and
lay waste my time.

This one was also seen only on the PDP11 port and showed up only when I added
support for the looping constructs at step 59 although I think it should have
popped up at step 58 as well.

Anyway, to begin at the beginning, the symptom of the problem I was running
into was that the PDP11 test would fail at the assert added in step 59 while
the x86 test passed without an error running the identical code changes.

Rather than use simh for debugging, I decided to go with "print debugging" and
so I added an implementation of '.' to defs.4th which prints out the value at
the top of the stack. I added a "dup ."  after the call to "outer" at step 59
in rom.4th to see why the assert was being hit and to see what that incorrect
value was. Unfortunately adding this "print" resulted in a hang while running
make within the pdp11 directory. (Note: when you run into a hang in simh, you
need to use Ctrl-e to break out of the hang, not Ctrl-c).

So now that things are going sideways rapidly, the next "print based debug" was
to add a "dup ." within cpl_ex to get a bigger picture of what was going on.

Running make in the pdp11 directory again after adding the newer print also
resulted in a hang. Getting out of the hang with Ctrl-e worked but doing so
made "make" remove the test.dict output file. So I needed to run whatever make
was running by hand. Since make only needs to run: "pdp11 simh_dict.cmds", I
just ran it manually then waited for it to hang and pressed Ctrl-e to get an
output file. The output in test.dict showed that a bunch of cfa's were
processed in the outer interpreter but to get more context I added another
debug print this time by adding "dup emit" at the start of "append".

The next round of testing was: make + Ctrl-e followed by another manual run
of: "pdp11 simh_dict.cmds" followed by Ctrl-e and then look at the generated
output in test.dict. At the tail end of the output, I noticed something that
caught my eye: the comments were being treated as compile/"exec"utable words.
And this pattern started soon after the code in the definition of "}else{"
which calls "[compile] }if" was processed. This code was added to the code as
step 58 in the previous commit where it appeared to work (ie my tests did not
signal any errors at step 58).

Since it was clear that something funny was going on with "[compile]", the next
debug print that I added was to check the value of the "state" variable. Since
PDP11 uses a padded out word for state due to alignment issues my guess was
that this difference was somehow triggering the difference in behavior on the
PDP11. But that line of thinking didn't turn up anything useful but all of that
debugging helped to narrow down the problem which could be now be summarized
as: "[compile] }if" was expected to result in "}if" being defexec'ed but it
looked like that wasn't happening on PDP11.

So the new round of debugging focused on the following execution chain:
	outer -> repl -> cpl_ex -> cpl_ex_imm -> defexec
mainly to see why the "exec" path inside defexec wasn't being taken on PDP11
when it needed to "defexec" the "[compile]'ed" word "}if".

defexec calls "isdefn" so the question was further narrowed down to see why
"isdefn" wasn't returning a "true" flag (on PDP11). This helped narrow it down
to ">=" not returning true. I verified that the values that were compared were
sane by "print"ing them out using '.' so the only code left to check was ">="
which was just a shim layer over '~' and just browsing the code and seeing the
difference between the code and the comment was enough of a hint to figure out
the bug - which was that the PDP11 implementation of '~' mistakenly used the
constant 0xF000 instead of 0x8000.

In hindsight, looking back at the other commits made on 15 Dec, it looks like
it was, all in all, a pretty productive day with a lot of progress made for the
PDP11 port, but doing too much on one day may have made me careless enough that
I let this bug slip through. Note that the "proof comment" that accompanies the
code was correct while the code itself was wrong (and the code had diverged
from the comment). The simple test case used to exercise the code did pass so
I could also attribute it to insufficient testing. In any case, it seems clear
that the bug might have been just a typo - ie, not a "thinko".

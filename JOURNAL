INDEX
-----
	* 11 Nov '22
	* 13 Nov '22
	* 15 Nov '22
	* 18 Nov '22

11 Nov '22
----------
The difficulty I'm running into now with the C port is that it is turning into
what appears to be a long drawn out struggle between C and Forth to figure out
who has first dibs on access to the system.

Forth obviously considers the entire machine as personal property unto itself,
to treat as it wishes. For example, Forth needs access to the return stack but
modifying the return stack in C looks like a fairly heavyweight operation using
getcontext/setcontext or other lower level alternatives using "asm"

There is also clearly an impedance mismatch between Forth's view of memory and
the memory abstraction that C provides - especially since the Forth bit'ness
of this implementation by design is 16 bits vs whatever processor bit width it
happens to be on the system that the C compiler is running on.

Rather than go into contortions trying to make the two world views conform to
fit each other, I'll call this port to C complete, for the most part, since new
Forth definitions can be added to defs.4th (although clipping its wings like
this makes for a very crippled/powerless Forth implementation).

So it does look like there is a real need for direct access to the CPU to have
Forth's power shine forth, so I think I'll go back to the original roadmap and
pick up things back up from where I left off, looking at what port to do next.

13 Nov '22
----------
Rather than jump directly into selecting a processor for the next round of the
porting exercise, I decided to take a step back to look at where I could be
more productive and not waste time on repetitive grunt work.

So now that I've done the porting exercise a couple of times, one thing that
I've found which appears to be a serious waste of time is starting over from
scratch for each port with an empty rom.4th and then adding the same generic
code over and over again after each step as the port progresses. For example,
the rom.4th changes to verify the key/emit functionality was done in commit
589f315d74e90e3e097112dc8760b41cdf958a22 at the time of the initial bootstrap.
At the time of "porting" this change to GNU "as", the same set of changes was
done in rom.4th at commit 2eba44f4643e42c98b8cf654c3936a333a4e225d. This was
repeated yet again at the time of the C port, when the exact same set of
changes to rom.4th was made in commit 07c25aaf30e1a7dc0a566adc086e3d0a3f896519

So rather than repeat this for each port, it makes sense to abstract out
the generic code in rom.4th and delimit each step of the porting process
within that file so that we can increase a "step" variable after each step
of the porting process so that when all the "steps" are complete, and all the
tests run successfully, we can declare that port complete.

This removes all of the duplicated effort that goes into keeping the tests
(which are part of rom.4th) in sync with each of the porting steps. Instead
of that approach, the new process ensures that the rom.4th contents remain
the same for all ports and the only thing that changes is the "step" variable
(which in some sense denotes the progress of a specific port).

Only time will tell if this "premature standardization" is a good thing or not.

As part of this process, I've also decided to add yet another primitive and
sneak it into the rom.4th "standard" as part of this overhaul. The primary
reason to add it in is for symmetry with "pick". For lack of a better name,
I'm calling it "stick" and like "pick", which gets an element from the stack,
"stick" replaces an element in the stack with a new value.

To parameterize individual ports, I've added a provision for Perl/shell-like
"dollar" variables. Since the code processor does not yet exist, I've not
modified the existing rom.4th files but created the new/generic version at
the top level. As this gets fleshed out and tested, the other rom.4th files
will be eventually obsoleted and removed.

---

That's it for the technical part of this journal entry. On a personal note,
as of today, it is 13 years since Lisa died. She would have been just the age
at which I was getting into the swing of all things related to coding. I wonder
if she would have chosen to be a coder like me.

Anyway, miss you Lisamma.

15 Nov '22
----------
I'm yet again at the crossroads of choosing a processor to work on next and as
with the earlier choice that was made, of fleshing out the generic test code in
rom.4th first, I've chosen to again start off by writing up what amounts to an
elaborate and generic how-to/"process document" on how to go about the porting
exercise for any given processor. It is meant to match up with the "step"s in
the rom.4th test cases although there isn't an exact 1-1 correspondence since
this "code" is meant to be more for human consumption than for direct use by
machine.

This is also an attempt to consolidate the things I've learnt from the previous
round of porting exercises that have been completed so far and the expectation
is that this "code" will continue to be updated with newer ideas as I work on
additional ports for other CPUs.

Since it is written for a "generic" CPU, I've placed it under pseudo/code since
much of the "code", if you want to call it that, is a mishmash of C and Forth
along with some non-C like notation for auto increment/decrement borrowed from
6809 assembly code. Although it is pseudo-code I've written it in a way such
that it may be possible to write a parser for it and turn it into machine code.

18 Nov '22
----------
This is starting to become a pattern now I guess: everytime I think I should
start on a new port, the overhang of the previous work takes me off on yet
another tangent. In this case it is an attempt to make sure that the new
version of the tests in rom.4th can actually work seamlessly with the original
code. The newer version of rom.4th had some changes from the version in the
port directories so I assume it is wise to test stuff out now on known code
rather than figure things out the hard way on unknown code where I'm wrangling
a new CPU and new toolchain along with the newer tests. It will also prove
if this strategy was a good choice to begin with.

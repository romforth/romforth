INDEX
-----
	* 11 Nov '22
	* 13 Nov '22
	* 15 Nov '22
	* 18 Nov '22
	* 30 Nov '22
	* 01 Dec '22
	* 03 Dec '22
	* 05 Dec '22
	* 06 Dec '22
	* 07 Dec '22
	* 08 Dec '22

11 Nov '22
----------
The difficulty I'm running into now with the C port is that it is turning into
what appears to be a long drawn out struggle between C and Forth to figure out
who has first dibs on access to the system.

Forth obviously considers the entire machine as personal property unto itself,
to treat as it wishes. For example, Forth needs access to the return stack but
modifying the return stack in C looks like a fairly heavyweight operation using
getcontext/setcontext or other lower level alternatives using "asm"

There is also clearly an impedance mismatch between Forth's view of memory and
the memory abstraction that C provides - especially since the Forth bit'ness
of this implementation by design is 16 bits vs whatever processor bit width it
happens to be on the system that the C compiler is running on.

Rather than go into contortions trying to make the two world views conform to
fit each other, I'll call this port to C complete, for the most part, since new
Forth definitions can be added to defs.4th (although clipping its wings like
this makes for a very crippled/powerless Forth implementation).

So it does look like there is a real need for direct access to the CPU to have
Forth's power shine forth, so I think I'll go back to the original roadmap and
pick up things back up from where I left off, looking at what port to do next.

13 Nov '22
----------
Rather than jump directly into selecting a processor for the next round of the
porting exercise, I decided to take a step back to look at where I could be
more productive and not waste time on repetitive grunt work.

So now that I've done the porting exercise a couple of times, one thing that
I've found which appears to be a serious waste of time is starting over from
scratch for each port with an empty rom.4th and then adding the same generic
code over and over again after each step as the port progresses. For example,
the rom.4th changes to verify the key/emit functionality was done in commit
589f315d74e90e3e097112dc8760b41cdf958a22 at the time of the initial bootstrap.
At the time of "porting" this change to GNU "as", the same set of changes was
done in rom.4th at commit 2eba44f4643e42c98b8cf654c3936a333a4e225d. This was
repeated yet again at the time of the C port, when the exact same set of
changes to rom.4th was made in commit 07c25aaf30e1a7dc0a566adc086e3d0a3f896519

So rather than repeat this for each port, it makes sense to abstract out
the generic code in rom.4th and delimit each step of the porting process
within that file so that we can increase a "step" variable after each step
of the porting process so that when all the "steps" are complete, and all the
tests run successfully, we can declare that port complete.

This removes all of the duplicated effort that goes into keeping the tests
(which are part of rom.4th) in sync with each of the porting steps. Instead
of that approach, the new process ensures that the rom.4th contents remain
the same for all ports and the only thing that changes is the "step" variable
(which in some sense denotes the progress of a specific port).

Only time will tell if this "premature standardization" is a good thing or not.

As part of this process, I've also decided to add yet another primitive and
sneak it into the rom.4th "standard" as part of this overhaul. The primary
reason to add it in is for symmetry with "pick". For lack of a better name,
I'm calling it "stick" and like "pick", which gets an element from the stack,
"stick" replaces an element in the stack with a new value.

To parameterize individual ports, I've added a provision for Perl/shell-like
"dollar" variables. Since the code processor does not yet exist, I've not
modified the existing rom.4th files but created the new/generic version at
the top level. As this gets fleshed out and tested, the other rom.4th files
will be eventually obsoleted and removed.

---

That's it for the technical part of this journal entry. On a personal note,
as of today, it is 13 years since Lisa died. She would have been just the age
at which I was getting into the swing of all things related to coding. I wonder
if she would have chosen to be a coder like me.

Anyway, miss you Lisamma.

15 Nov '22
----------
I'm yet again at the crossroads of choosing a processor to work on next and as
with the earlier choice that was made, of fleshing out the generic test code in
rom.4th first, I've chosen to again start off by writing up what amounts to an
elaborate and generic how-to/"process document" on how to go about the porting
exercise for any given processor. It is meant to match up with the "step"s in
the rom.4th test cases although there isn't an exact 1-1 correspondence since
this "code" is meant to be more for human consumption than for direct use by
machine.

This is also an attempt to consolidate the things I've learnt from the previous
round of porting exercises that have been completed so far and the expectation
is that this "code" will continue to be updated with newer ideas as I work on
additional ports for other CPUs.

Since it is written for a "generic" CPU, I've placed it under pseudo/code since
much of the "code", if you want to call it that, is a mishmash of C and Forth
along with some non-C like notation for auto increment/decrement borrowed from
6809 assembly code. Although it is pseudo-code I've written it in a way such
that it may be possible to write a parser for it and turn it into machine code.

18 Nov '22
----------
This is starting to become a pattern now I guess: everytime I think I should
start on a new port, the overhang of the previous work takes me off on yet
another tangent. In this case it is an attempt to make sure that the new
version of the tests in rom.4th can actually work seamlessly with the original
code. The newer version of rom.4th had some changes from the version in the
port directories so I assume it is wise to test stuff out now on known code
rather than figure things out the hard way on unknown code where I'm wrangling
a new CPU and new toolchain along with the newer tests. It will also prove
if this strategy was a good choice to begin with.

30 Nov '22
----------
I think the x86 port is now complete (yes, really, at least to my satisfaction)
now that the last of the annoying little techdebt details are cleared. So I can
declare unambiguosly that it is now time to start on the next port.

In the initial list of architectures that I had listed in the PORTING doc, I
realized that I missed a truly important one: the PDP11 (I've updated it there
now). In my early student days, we covered the PDP11 as part of the course on
"Computer Organization" based on the textbook of the same name authored by
V. Carl Hamacher, Zvonko G. Vranesic and Safwat G. Zaky.

---

A small personal anecdote about this book : I bought this book long, long ago
when I was a student (when it, quite literally, cost a fortune). From the
scribbles on the back of the book, it looks like the price was $7.95 (USD? or
more likely Singapore Dollar, since it is the "International Student Edition"
printed in Singapore) and it was sold for the princely sum of Indian Rs 125/-
which in my student days would probably have been about ~2-4 months worth of
lunch money. This was in the late 80's so I'm really dating myself here. I'm
really grateful that my Dad (Happy Birthday, Apai!) and Mom plunked down their
hard earned money to buy this book for me.

Thank you Apai & Mom! :heart: :RIP:

---

Switching back to the technical discussion, the pseudo code (in pseudo/code)
that I wrote to help with the porting reminded me of how well attuned the PDP11
instructions are to the programmers needs from an assembly coding point of view

I'll assume that the instruction sets of the 68000 and the MSP430, both of
which are elegant in their own ways, all trace their lineage back to this
beautifully crafted, gem of an ISA. Obviously, I can only talk about what I
know, so in case the PDP11 inherited its elegance from an earlier design, then
hey, here's a shout out to them too.

Some research into how to emulate a PDP11 and cross-compile/build for it led me
to: https://ancientbits.blogspot.com/2012/07/programming-barebones-pdp11.html
which walks through all of the steps required to do this in excellent detail.

The quick summary/cheatsheet is:
- Build/install binutils (for pdp11-aout-as and pdp11-aout-ld)
- Build/install simh to emulate the PDP11
- Build bin2load from https://github.com/jguillaumes/retroutils
  This utility is used to modify the a.out binary generated by the pdp11 as/ld
  into a "lda" binary which can be load'ed directly by simh during emulation.

Using these instructions I was able to successfully complete the "Preamble"
step of porting documented in pseudo/code for the PDP11 port.

01 Dec '22
----------
Starting at step 0 of the porting work for PDP11 brought me back to yet another
round of thinking about the format of code.prims. So far, I've used the
	code{ ... }code, inner{ ... }inner and fallthru
among other directives for the assembly language primitives of the x86 ports
but looking back at it now, I find all of that a bit too verbose compared to
the spareness of Forth's own : ... ; notation. So as an experiment, I'm going
to try doing an exercise in extreme minimalism: what if assembly code did not
use any type of decoration whatsoever?

So the plan is that assembly code will be written in code.prims in the format:
	forthlabel : assembly-line1 ; assembly-line2 ; ... ;
all on one line to improve the "code density". The "forthlabel" is just the
conventional forth word name and the assembly code delimited by the semicolons
implement that word.

Since this will be preprocessed by the genprims script anyway, I'm thinking of
putting a spin on it though, where ';' will serve multiple purposes which
hopefully won't cause me too much confusion down the line.

As mentioned above, the ';' serves to delimit independent assembly code lines
but the new spin on it is that it also serves to denote calling "next" if it
is the terminating character on a line. If the line is not terminated by a
semicolon, the expectation is that the code will fall through to the next line
of code below it. So code blocks that currently looks like this:

	code{
	foo bar
		line1
		line2
		...
	}code

will turn into this:

	foo : line1 ; line2 ; ...

Note that the assembly label "bar" in the original code is no longer needed
since it will be auto-generated by the genprims script. In the initial x86
port, "bar" was usually a copy of "foo" if "foo" was alphanumeric (for example
"emit emit") or an alphanumeric replacement (for example "@ fetch"). I've
tried to semi-automate this by using the forth label if it is alphanumeric.

Similarly, inner{ ... }inner code blocks that currently looks like this:

	inner{
	foo bar
		line1
		line2
		...
	}inner

will turn into this:

	foo : line1 ; line2 ; ... ;

Note the addition of the terminating ';' in case of "inner" blocks which is
meant to denote adding the implicit call to "next".

Code blocks that needed "fallthru" can also be denoted in the new scheme just
by leaving out the terminating semicolon. Hopefully, this will make for a much
shorter and crisper implementation.

Although the purpose of the overall project is to showcase a really small Forth
implementation, simh/PDP11 provides me 64K of RAM which is such a luxury that
I'm going on a splurge and use an entire 16 bits for each word offset. This is
a code size win even for jsr calls so I'm not going to go into contortions to
reduce the offset down to 8 bits - although that should be fairly easy as well.

03 Dec '22
----------
Getting output to the console working under simh was not too much of a hassle
since I was continuing to follow the really helpful notes at
https://ancientbits.blogspot.com/2012/07/programming-barebones-pdp11.html

I did simplify the code, a lot, though, based on the sample code from the
"PDP11 Peripherals and Interfacing Handbook", an online copy of which is
available from:
http://www.bitsavers.org/pdf/dec/pdp11/handbooks/PDP11_PeripheralsHbk_1972.pdf

Although I initially used the console device for output, one difficulty I ran
into with using it was with trying to redirect that output to a named file. In
the end, I decided that the struggle was not worth it and just decided to use
a different device (the line printer, LPT/LP11) since simh allows it to be
directly attach'ed to a named file.

Next, I just need to do the same thing for console input as well. Let's see
how long figuring that one out takes.

05 Dec '22
----------
Sometimes it is the simplest things that take the longest to get done. It turns
out the premonition I had about redirecting the input from a file as mentioned
in my previous journal entry turned out to be fairly spot on.

My first attempt at implementing "key" was to use the console device and it
worked without much debugging - using the sample code from Digital in the
"PDP11 Peripherals and Interfacing Handbook" available from:
http://www.bitsavers.org/pdf/dec/pdp11/handbooks/PDP11_PeripheralsHbk_1972.pdf
came in pretty handy again.

Since I want to be able to automate the testing though, the next attempt was
to redirect the input from a file. I initially tried to use the same approach
that succeeded for me with "emit" (where I used the LPT device instead of the
DL11 console output). I thought I could attach the "Paper Tape Reader"/PC11/ptr
device to the input file and change the addresses from 017756X to 017755X and
call it a day. But for some unknown reason I haven't been able to get that
working so far. Running ex'amine on the device shows that the data exists as
expected but the code kept looping as if the data wasn't available. Rather than
spend even more time on trying to fix whatever was broken, I decided to read
through the simh docs to see if there was another device I could test instead
but happened to see the "send" command that allows you to inject data into the
console input. So for now, I've decided to use that feature as a workaround.

Given the time I've spent trying to get this working on simh, I now wonder if
it wouldn't have been faster to just write yet another emulator for the pdp11
just like I did for the x86. Perhaps, if I get stuck again, that's just what
I'll do.

06 Dec '22
----------
For implementing the data stack on the PDP11, there is a literal profusion of
choices since any of the PDP11 registers can be used as the data stack pointer
(given the PDP11's flexible addressing modes).

Since I want to see if the native/machine stack can be used for the return
stack, I'll choose the next available register (r2), rather than r6 as the
data stack pointer. The current register mapping is: R0: IP, R1: TOS, R2: SP

The remaining decision is about where to place the data stack. I'll make the
same choice that I made on the x86 port, which is to have it grow to low memory
starting from the beginning of the text area. So the current memory layout
looks like this:

			0x100 -> higher memory
	  ------------------------------
	   <- data stack | code/text ->
	  ------------------------------

07 Dec '22
----------
During the x86 port, I chose to use the macro features of the x86 assembler
to do all of the macro expansions that were needed when a Forth word used a
"lower" level forth word. For the PDP11 port though, I want to try something
different and have most of those expansions done by genrom instead. This seems
to be a cleaner approach than the ugliness of the x86 version where I have
to disambiguate between the macro expansion and a regular call by using '_' to
prefix the words that needed to be expanded.

So this required a little bit of addition to genrom's capabilities.

In the x86 port, I was using 8 bit offsets so all of the addresses were stored
as offsets from the base of the text area. Since I'm using the full 16 bits
for the PDP11 port, I can store the addresses as is.

08 Dec '22
----------
While working my way through "step 5" to implement conditionals on the PDP11
I decided that the scope of this step is too large and needs to be broken up
into smaller steps which are finer grained and more easily tested.

I also found that using "jmp" as a label seems to cause a hiccup for the
PDP11 assembler so it needs to be renamed to something other than "jmp".
I'll pick "j" as the replacement name, for now.

So, my solution to address these issues is to separate out the support for
implementing the primitives "j/jz/jnz" into 3 sub-steps which I'm calling
steps 4.1, 4.2 and 4.3 and then follow that up with the implementation for
"if{ ... }else{ ... }if" in genrom (which remains the same as before) as
part of the original "step 5".

I chose to use the floating point notation for the newer steps since it
allows me to not have to redo the numbering for all of the the other later
steps, thus keeping those step numbers the same, just in case they are
referred elsewhere.

Since it is quite useful to be able to test each of the basic "j/jz/jnz"
primitives independently of the language support (which is only added later
in "step 5"), some standalone/newer tests for these steps have been added
to rom.4th as well. This change then snowballed into requiring changes to
test.inp and test.expected as well. So while I was there I decided to clean
up the conditions used for the earlier tests from "step>N-1" to "step>=N"
which makes it easier to match up each test with the corresponding "step"
during coding and testing.

Since more granular steps are being added, I decided it is safer to test
it all out on the x86 ports first before trying it out on the PDP11 port.

One addition that I've made to the genrom feature set is the ability to
use "immediate offsets" which are different from the "immediate literals".
The "literals" are the usual Forth literals prefixed with the lit operator
and can be denoted as bare numbers/variables or prefixed with the $ notation.

The "offsets" are new and are used for encoding JUMP offsets which don't
need to be prefixed with 'lit' - they are denoted using a '#' prefix.

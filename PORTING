The following ports are complete:
=================================

.-----------.------.--------.---.-----------.------------.---------------.
| CPU       | Bits | Endian | T | API       | Build      |     Test      |
+-----------+------+--------+---+-----------+------------+---------------+
| x86       |  16  | little | 1 | Baremetal | nasm       | DIY emulator  |
| x86-as    |  16  | little | 1 | Baremetal | GNU as     | DIY emulator  |
| PDP11     |  16  | little | 2 | Baremetal | GNU as     | simh/pdp11    |
| x86-user  |  64  | little | 1 | libc/musl | gcc/zig cc | Host/Native   |
| C/x86     |  64  | little | 3 | libc/musl | gcc/zig cc | Host/Native   |
| x86-32    |  32  | little | 1 | libc/musl | gcc/zig cc | Host32/Native |
| x86-sys   |  64  | little | 1 | Linux/sys | GNU as     | Host/Native   |
| m68k      |  32  |  big   | 1 | Linux/sys | GNU as     | qemu-m68k     |
| sparc     |  32  |  big   | 1 | Linux/sys | GNU as     | qemu-sparc    |
| z80-c     |  16  | little | 3 | Baremetal | sdcc       | ucsim/sz80    |
'-----------'------'--------'---'-----------'------------'---------------'

Notes for the table above:
	T : The "thread" type used in the interpreter - this needs some form of
		a mapping to the usual Forth notation of DIRECT/INDIRECT/STC/...

Porting Guide
=============
This is just a high level summary of the more detailed steps outlined in
pseudo/code. The very first "preamble" step is to pick a porting target and
figure out the build/emulate/test toolchain.

If you prefer to look at an existing implementation as a guide, you could pick
any one of the completed ports and follow each of those steps until all steps
are complete.

Instead, if you prefer to get a more abstract view, you can look at the steps
outlined in pseudo/code (NOTE: the steps in pseudo/code are independent of the
"steps" used in the real ports, I need to sync them up RSN).

Currently there are a total of about 73 "bite size" steps. The first few steps
can be summarized as getting the equivalent of the following code in C running
on your target system: int main() { putchar( getchar() ); exit(0); }

These represent the external/environmental dependencies of your implementation.

From an operational point of view, after you have setup the directory for
a new port, you just need to make the appropriate changes at each step and
then keep running ../git_auto_commit `basename $PWD` inside that directory
which will take care of creating a git commit with the appropriate subject
line for each step.

Since the makefile is very target dependent, you could make a copy of any one
of the existing ports and modify as appropriate.

At step 22, you will need to switch from oneforth to twoforth in the makefile
At step 41, you will need to switch from twoforth to threeforth in the makefile
After step 62, you can switch from threeforth to fourforth in the makefile.
See the corresponding changes that were made in the commit history of the z80-c
port for details (ignore the earlier ports where these changes were made kinda
helter-skelter)

To make porting easier, the machine independent code in Forth uses a bunch of
configuration settings which are stored in the fpp.config.* files. These need
to be modified as appropriate.

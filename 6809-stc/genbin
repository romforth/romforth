#!/usr/bin/perl -w

# genbin : convert the Perl nested array "AST" into native code
#
# Copyright (c) 2025 Charles Suresh <romforth@proton.me>
# SPDX-License-Identifier: AGPL-3.0-only
# Please see the LICENSE file for the Affero GPL 3.0 license details

use strict;

my $f=shift or die "usage: $0 file";
my $x=require $f or die "parse failed";

my $prefix=$f;
$prefix=~s/^(\w+).*$/$1/;

sub lit {
	my ($l)=@_;
	my $o=$l->[1];
	print qq(\tdup ; dup\n);
	print qq(.db 0xCC ; ldd\n);
	print qq(.dw #$o\n);	# $o ; tos <- $o
}

my $jmp;

sub prim {
	my ($w)=@_;
	my $o=$w->[1];
	print "\t$o ; $w->[0]\n";
}
sub word {
	my ($w)=@_;
	my $o=$w->[1];
	if ($o eq 'j') { $jmp='j' ; return; }
	if ($o eq 'jz') { $jmp='jz' ; return; }
	if ($o eq 'jnz') { $jmp='jnz' ; return; }
	print "\t$o ; $w->[1]\n";
}

sub skip {
	my ($s)=@_;
	my $o=$s->[1];
	#print "$jmp $o\n";
	if ($jmp eq 'j') {
		print ".db 0x80, $o ; sjmp offset\n";
	} elsif ($jmp eq 'jz') {
		print "cpl a\n";
		print "mov r1, a\n";
		print "\tdrop ; drop\n";
		print ".db 0xB9, 0, $o ; cjne r1, #0, offset\n";
	} elsif ($jmp eq 'jnz') {
		print "nop\n"; # to keep the number of bytes the same as jz
		print "mov r1, a\n";
		print "\tdrop ; drop\n";
		print ".db 0xB9, 0, $o ; cjne r1, #0, offset\n";
	}
}

my $label="${prefix}lbl000";

sub cond {
	my ($s)=@_;
	my $i=$s->[1];	# AST for the 'if' part
	my $e=$s->[2];	# AST for the 'else' part
	print "jz $label", "_then\n";
	print "\tdrop ; drop\n";
	my ($l,$c)=($label++, "_then");
	my $si = walk($i);	# expand out the 'if' part of the AST
	if (defined $e and @$e != 0) {
		print "sjmp ", $l, "_endif\n";
		print $l, $c, ":\n";
		print "\tdrop ; drop\n";
		$c='_endif';
		my $se = walk($e);	# expand out the 'else' part of the AST
		print $l, $c, ":\n";
	} else {
		print ".db 0x80, 2 ; sjmp +2\n";
		print $l, $c, ":\n";
		print "\tdrop ; drop\n";
	}
}

sub def {
	my ($s)=@_;
	#print "$s->[0]  name:$s->[1],  label:$s->[2], imm: $s->[3]\n";
	print "$s->[2] : ; $s->[1]\n";
	my $se = walk($s->[4]);	# expand out the body of the definition
	print "ret\n";
}

sub visit {
	my ($s)=@_;
	#print "$s->[0]  label:$s->[1],  name:$s->[2]\n";
	print "acall $s->[1] ; $s->[2]\n";
}

sub loop {
	my ($l)=@_;

	# loop can be invoked in a couple of different scenarios:
	# 1. an unconditional loop such as : [ 'loop', [...], [...] ]
	# 2. or as a 'while' loop : [ 'loop', [...], 1, [...] ]
	# 3. or as an 'until' loop : [ 'loop', [...], 0, [...] ]

	my $t; # denotes the 'type' of the loop:
	# type -1 means unconditional, 0 is for until and 1 for while

	my $c=$l->[1];	# the conditional/first part of the loop
	my $lbl=$label++;
	print "$lbl", "_begin:\n";
	my $lc = walk($c);

	my $b=$l->[2];	# this could be either the body of the loop or the type
	if (ref $b eq 'ARRAY') {	# unconditional loop
		$t=-1;
	} else {			# conditional loop
		$t=$b;			# set to either 1: while or 0: until
		$b=$l->[3];
	}
	if ($t==1) {			# conditional while loop
		print "jz $lbl", "_end\n";
	} elsif ($t==0) {		# conditional while/until loop
		print "jnz $lbl", "_end\n";
	} else {			# unconditional loop
		# no code needs to be generated
	}
	my $lb = walk($b);
	print "sjmp $lbl", "_begin\n";
	print "$lbl", "_end:\n";
	print "\tdrop ; drop\n";
}

my $fhash={
	'word' => \&word,
	'lit' => \&lit,
	'skip' => \&skip,
	'cond' => \&cond,
	'prim' => \&prim,
	'def' => \&def,
	'visit' => \&visit,
	'loop'	=> \&loop,
};

my $fn;

sub walk { # walk through the Abstract Syntax Tree
	my ($t)=@_;
	for my $i (@$t) {
		$fn=$fhash->{$i->[0]} or die "unmapped fn ".$i->[0];
		$fn->($i);
	}
}
#use Data::Dumper; print Dumper($x);
walk($x);

# code.prims : mapping from the Forth primitives to native code (x86 assembly)
#
# Copyright (c) 2022 Charles Suresh <romforth@proton.me>
# SPDX-License-Identifier: AGPL-3.0-only
# Please see the LICENSE file for the Affero GPL 3.0 license details

code{
bye halt
	hlt
}code

define tos %bx
define nos %cx
define   w %ax
define  ip %si

define next jmp *%bp

define _nip pop nos
define _dip push nos
define _dup push tos
define _drop pop tos
define _inc inc tos
define _dec dec tos
define _neg neg tos
define _inv not tos
define _xchg xchg tos, nos
define _fetch mov (tos), tos

code{
jmp branch		# [	| w	| ip	] (ip:v)
	lodsb           # [	| v	| ip+1	] // al=*si++
	cbw		# [	| V	| ip+1	] // sign extend al into ah
	add w, ip	# [	| V	| ip+1+V] // si += ax
	jmp restoreax	# jmp inner, but restore ax first
}code

inner{
jz branchz		# [ x	| w	| ip	]
	neg tos		# [ -x	| w	| ip	] // if tos!=0, set carry
	_drop		# [	| w	| ip	]
	jnc branch	# [	| w	| ip	] // if tos==0, goto branch
	inc ip		# [	| w	| ip+1	] // otherwise skip over offset
}inner

inner{
jnz branchnz		# [ x	| w	| ip	]
	neg tos		# [ x	| w	| ip	] // if tos!=0, set carry
	_drop		# [	| w	| ip	]
	jc branch	# [	| w	| ip	] // if tos!=0, goto branch
	inc ip		# [	| w	| ip+1	] // otherwise skip over offset
}inner

inner{
key key
	_dup		# save tos
	in %dx, %al	# read from serial port
	xor tos, tos	# just need to clear TOS.h
	mov %al, %bl	# save byte read in TOS.l
}inner

inner{
emit emit
	mov %bl, %al	# restore stashed value
	out %al, %dx	# and echo it out to the serial port
	_drop		# drop displayed value in TOS
}inner

inner{
lit lit			# [ x	| w | ip ] (ip:v)
	_dup		# [ x x	| w | ip ]
	mov w, tos	# [ x w | w | ip ]	// just to preserve AH
	lodsw		# [ x w | v | ip+2 ]
	xchg w, tos	# [ x v | w | ip+2 ]	// to restore AH and set tos
}inner

fallthru 2drop drop2 _drop	# drop	# and then fall thru to drop
unary drop drop _drop
unary dup  dup  _dup
unary nip  nip  _nip

				# [ addr	(addr:val)
unary @    fetch _fetch		# [ val

inner{
! store				# [ val addr
	pop (tos)		# [ addr	(addr:val)
	_drop			# [
}inner

				# [ a b
fallthru swap swap _nip		# [ b	// nos=a and fall thru to xchg
fallthru xchg xchg _xchg	# [ a	// nos=b and fall thru to dip
unary dip  dip  _dip		# [ b a

unary inc  inc  _inc
unary dec  dec  _dec
unary neg  neg  _neg
unary inv  inv  _inv

fallthru - sub _neg	# tos = -tos # and then fall thru to addition
binary + add add nos, tos
binary & and and nos, tos
binary |  or  or nos, tos
binary ^ xor xor nos, tos

inner{
<< shl			# [ n s
	mov %bl, %cl	# [ n s	// cl <- s.l
	_drop		# [ n
	shl %cl, tos	# [ n<<cl
}inner

inner{
>> shr			# [ n s
	mov %bl, %cl	# [ n s	// cl <- s.l
	_drop		# [ n
	shr %cl, tos	# [ n>>cl
}inner

var here here .word mem

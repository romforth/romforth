#!/usr/bin/perl -w
use strict;

my $map={};	# mapping from forth words to assembly labels

my ($f,$l);	# the forth name($f) and the assembler label ($l)

my @args=@ARGV;	# all the args are assumed to have name to label mappings
for my $a (@args) {
	@ARGV=($a);		# read each of the args passed in as a file
	while(<>) {		# reading one line at a time
		($f,$l)=split;	# split'ing the line into the name and label
		$map->{$f}=$l;	# and generate the mapping from name to label
	}
}

my $m;					# cache for the map from name to label
while (<>) {				# map forth words in the standard input
	for $f (split) {		# for each word to their equivalent
		if ($m=$map->{$f}) {	# byte offset within the binary
			print "\tdb ", $map->{$f}, "\n";
		} else {		# or whine if the mapping doesn't exist
			last if ($f eq '[');	# skip to end of line
			if ($f =~/^\'(.)\'$/) {	# char in single quotes
				my $o=ord($1);	# to get the ascii value
				print qq(\tdb lit\n);
				print qq(\tdw $o\n);
				next;
			} elsif ($f =~/^(\d+)$/) {
				my $o=int($1); # atoi equivalent
				print qq(\tdb lit\n);
				print qq(\tdw $o\n);
				next;
			} elsif ($f =~/^0x([\dA-Fa-f]+)$/) {
				my $o=oct($1); # hex conversion
				print qq(\tdb lit\n);
				print qq(\tdw $o\n);
				next;
			}
			die "unknown word: $f"
		}
	}
}

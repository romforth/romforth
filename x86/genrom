#!/usr/bin/perl -w
use strict;

my $map={};	# mapping from forth words to assembly labels
my $varmap={};	# mapping from forth words to variables

my ($t,$f,$l);	# the type($t), forth name($f) and the assembler label ($l)

sub code {
	my ($f,$l)=@_;
	$map->{$f}=$l;	# generate the mapping from name to label
}
sub var {
	my ($f,$l)=@_;
	$varmap->{$f}=$l;
}
my $handle={
	'code' => \&code,
	'var' => \&var,
};
my @args=@ARGV;	# all the args are assumed to have name to label mappings
for my $a (@args) {
	@ARGV=($a);		# read each of the args passed in as a file
	while(<>) {		# reading one line at a time
		($t,$f,$l)=split;# split'ing the line into type, name and label
		$handle->{$t}($f,$l); # and handle each type separately
	}
}

my $m;					# cache for the map from name to label
while (<>) {				# map forth words in the standard input
	for $f (split) {		# for each word to their equivalent
		if ($m=$map->{$f}) {	# byte offset within the binary
			print "\tdb ", $map->{$f}, "\n";
		} elsif ($m=$varmap->{$f}) { # variables just need to
			print "\tdb lit\n";	# push their
			print "\tdw $m\n";	# address
		} else {		# or whine if the mapping doesn't exist
			last if ($f eq '[');	# skip to end of line
			if ($f =~/^\'(.)\'$/) {	# char in single quotes
				my $o=ord($1);	# to get the ascii value
				print qq(\tdb lit\n);
				print qq(\tdw $o\n);
				next;
			} elsif ($f =~/^(\d+)$/) {
				my $o=int($1); # atoi equivalent
				print qq(\tdb lit\n);
				print qq(\tdw $o\n);
				next;
			} elsif ($f =~/^0x([\dA-Fa-f]+)$/) {
				my $o=oct($1); # hex conversion
				print qq(\tdb lit\n);
				print qq(\tdw $o\n);
				next;
			}
			die "unknown word: $f"
		}
	}
}

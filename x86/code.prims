code{
bye halt
	hlt
}code

define next jmp bp

define tos bx
define nos cx
define   w ax
define  rp di

define _dup  push tos
define _drop pop tos
define _nip  pop nos
define _dip  push nos
define _neg  neg tos
define _inv  not tos
define _inc  inc tos
define _dec  dec tos
define _xchg xchg tos, nos

code{
p@ peek			; [ port	(port:byte) // ready to read
	mov dx, tos	; [ port	// dx is used for in/out
	in al, dx	; [ port	// al = peek(port)
	mov bl, al	; [ XX|byte	// copy from al to bl
	xor bh, bh	; [ byte	// zero the high byte
	jmp restoredx	;		to restore dx (and ah)
}code

code{
p! poke			; [ byte port	// ready to write
	_nip		; [ port	// nos=byte
	mov dx, tos	; [ port	// dx is used for in/out
	mov ax, nos	; [ port	// al is used for in/out
	out dx, al	; [ port	// poke(port, al)
	_drop		; [
	jmp restoredx	;		to restore dx (and ah)
}code

inner{
key key
	_dup		; save tos
	in al, dx	; read from serial port
	xor bx, bx	; just need to clear TOS.h
	mov bl, al	; save byte read in TOS.l
}inner

inner{
emit emit
	mov al, bl	; restore stashed value
	out dx, al	; and echo it out to the serial port
	_drop		; drop displayed value in TOS
}inner


code{
exec exec		; [ x	| w |	]
	mov al, bl	; [ x	| x |	]
	_drop		; [	| x |	]
	jmp ax		; exec the code corresponding to that offset
}code

inner{
lit lit			; [ x	| w | ip ] (ip:v)
	_dup		; [ x x	| w | ip ]
	mov tos, w	; [ x w | w | ip ]	// just to preserve AH
	lodsw		; [ x w | v | ip+2 ]
	xchg w, tos	; [ x v | w | ip+2 ]	// to restore AH and set tos
}inner

unary rp@! rpxchg xchg tos, rp
unary sp@! spxchg xchg tos, sp

fallthru 2drop drop2 _drop	; drop	# and then fall thru to drop
unary drop drop _drop
unary dup  dup  _dup
unary neg  neg  _neg
unary inv  inv  _inv
unary nip  nip  _nip
				; [ addr	(addr:val)
unary @    fetch mov tos, [tos]	; [ val // assume not reused, so no define macro

inner{
! store				; [ val addr
	pop word [tos]		; [ addr	(addr:val)
	_drop			; [
}inner

inner{
c@ cfetch			; [ addr	(addr:byte)
	mov bl, [tos]		; [ XX|byte	// fetch to lower half of TOS
	xor bh, bh		; [ byte	// clear top half of TOS
}inner

inner{
c! cstore			; [ byte addr
	_nip			; [ addr	// nos=byte
	mov [tos], cl		; [ addr	(addr:byte)
	_drop			; [
}inner
				; [ a b
fallthru swap swap _nip		; [ b	// nos=a and fall thru to xchg
fallthru xchg xchg _xchg	; [ a	// nos=b and fall thru to dip
unary dip  dip  _dip		; [ b a

unary inc  inc  _inc
unary dec  dec  _dec

fallthru - sub _neg	; tos = -tos # and then fall thru to addition
binary + add add tos, nos
binary & and and tos, nos
binary | or  or  tos, nos
binary ^ xor xor tos, nos

inner{
<< shl			; [ n s
	mov cl, bl	; [ n s	// cl <- s.l
	_drop		; [ n
	shl bx, cl	; [ n << cl
}inner

inner{
>> shr			; [ n s
	mov cl, bl	; [ n s	// cl <- s.l
	_drop		; [ n
	shr bx, cl	; [ n >> cl
}inner

inner{
>r tor			; [ x	|   ]
	mov [rp], tos	; [ x	| x ]
	_drop		; [	| x ]
	inc rp		; rp++
	inc rp		; rp++
}inner

inner{
r> fromr		; [ a	| x ]
	dec rp		; rp--
	dec rp		; rp--
	_dup		; [ a a	|   ] // x dropped because of the decrements
	mov tos, [rp]	; [ a x |   ] // but the content was still in memory
}inner

var here here dw mem
var state state db 0

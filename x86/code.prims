code{
bye halt
	hlt
}code

define next jmp bp

define tos bx
define nos cx
define   w ax

define _dup  push tos
define _drop pop tos
define _nip  pop nos
define _dip  push nos
define _neg  neg tos
define _inv  not tos
define _inc  inc tos
define _dec  dec tos
define _xchg xchg tos, nos

inner{
key key
	_dup		; save tos
	in al, dx	; read from serial port
	xor bx, bx	; just need to clear TOS.h
	mov bl, al	; save byte read in TOS.l
}inner

inner{
emit emit
	mov al, bl	; restore stashed value
	out dx, al	; and echo it out to the serial port
	_drop		; drop displayed value in TOS
}inner

inner{
lit lit			; [ x	| w | ip ] (ip:v)
	_dup		; [ x x	| w | ip ]
	mov tos, w	; [ x w | w | ip ]	// just to preserve AH
	lodsw		; [ x w | v | ip+2 ]
	xchg w, tos	; [ x v | w | ip+2 ]	// to restore AH and set tos
}inner

fallthru 2drop drop2 _drop	; drop	# and then fall thru to drop
unary drop drop _drop
unary dup  dup  _dup
unary neg  neg  _neg
unary inv  inv  _inv
unary nip  nip  _nip
				; [ addr	(addr:val)
unary @    fetch mov bx, [bx]	; [ val // assume not reused, so no define macro

inner{
! store				; [ val addr
	pop word [bx]		; [ addr	(addr:val)
	_drop			; [
}inner
				; [ a b
fallthru swap swap _nip		; [ b	// nos=a and fall thru to xchg
fallthru xchg xchg _xchg	; [ a	// nos=b and fall thru to dip
unary dip  dip  _dip		; [ b a

unary inc  inc  _inc
unary dec  dec  _dec

fallthru - sub _neg	; tos = -tos # and then fall thru to addition
binary + add add tos, nos
binary & and and tos, nos
binary | or  or  tos, nos
binary ^ xor xor tos, nos

inner{
<< shl			; [ n s
	mov cl, bl	; [ n s	// cl <- s.l
	_drop		; [ n
	shl bx, cl	; [ n << cl
}inner

inner{
>> shr			; [ n s
	mov cl, bl	; [ n s	// cl <- s.l
	_drop		; [ n
	shr bx, cl	; [ n >> cl
}inner

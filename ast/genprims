#!/usr/bin/perl -w

# genprims : convert code.prims into a Perl dictionary (an AST, actually)
#
# Copyright (c) 2025 Charles Suresh <romforth@proton.me>
# SPDX-License-Identifier: AGPL-3.0-only
# Please see the LICENSE file for the Affero GPL 3.0 license details

use strict;

my $mf=shift;	# the map file to be generated

my $gendict=0;
if ($mf eq "-d") {
	$gendict=1;
	$mf=shift;	# the map file to be generated
}
open(my $mh, ">$mf") or die "can't open $mf for writing";

my ($f,$l);	# the forth name($f) and the assembler label ($l)

my $prev="0";

my $headers=[];

sub mapnames {
	($f,$l)=@_;	# which provides forth<->label mapping
	print $mh "code $f $l\n";	# create dictionary entry for primitives
	print "\t\t'$f' => [ '$f', '$l', 0, [\n";
}

my $hash={};
my $agg=[];
my $label="lbl000";
print "{\n\t'code' => {\n";
my $state='code';
while (<>) {
	/^\#/ and next;
	if (s/^\s*(\S+)\s+:\s+//) {
		$f=$1;
		if ($f=~/^[a-z]\w*$/) {
			mapnames($f, $f);
		} else {
			mapnames($f, $label++);
		}
		for my $w (split(' ;')) {
			chomp $w;
			$w="next" unless ($w);
			$w=~s/^\s+//;
			if ($l=$hash->{$w}) {
				print "'\t", join("\n',\n'\t",@$l), "\n',\n";
				push @$agg, @$l unless ($w eq "next");
			} else {
				$w=~s/\'/\\\'/g;
				print "'\t$w\n',\n";
				push @$agg, $w;
			}
		}
		print "\t\t\t]],\n";
		$hash->{"$f"}=[@$agg];
		$agg=[];
		next;
	}
	if (/^define\s+(\S+)\s+(.*)$/) {	# definitions
		print "#define $1 $2\n";
		print "\t},\n\t'define' => {\n" if ($state ne'define');
		$state='define';
		print "\t'$1' => ['$1', '$2', []],\n";
		next;
	} elsif (/^var\s+(\S+)\s+(.*)$/) {	# variables
		($f)=($1);
		print $mh "var $f $f\n";	# create dictionary entry for variables
		print "\t},\n\t'var' => {\n" if ($state ne'var');
		$state='var';
		print "\t\t'$f' => ['$f', '$f', []],\n";
		next;
	}
	next if (/^\s*$/);
	chomp;
	die "unknown declaration: '$_'";
}
print $mh "label fake $label\n";
close $mh;
print "\t},\n\t'fake' => '$label'\n}\n";

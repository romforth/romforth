#!/usr/bin/perl -w

# genast : convert the .4th files into a Perl nested array "AST"
#
# Copyright (c) 2025 Charles Suresh <romforth@proton.me>
# SPDX-License-Identifier: AGPL-3.0-only
# Please see the LICENSE file for the Affero GPL 3.0 license details

use strict;

use Getopt::Long;
my ($gendict,$gendefs)=(0,0);
GetOptions(
	'dict' => \$gendict,
	'gendefs' => \$gendefs,
);

my $mf=shift;   # the map file to which new defs are written
open(my $mh, ">$mf") or die "can't open $mf for writing";

my $map={}; # mapping from forth words to C labels
my $varmap={};  # mapping from forth words to variables
my $defs={};	# mapping from forth words to definition labels
my $deford=[];  # ordered list of definitions

my ($t,$f,$l);  # the type($t), forth name($f) and the C label ($l)

sub code {
	my ($f,$l)=@_;
	$map->{$f}=$l;  # generate the mapping from name to label
}
sub var {
	my ($f,$l)=@_;
	$varmap->{$f}=$l;
}

sub olddef {
	my ($f,$l,$d)=@_;
	$defs->{$f}=[$d,$l];
	push @$deford, [$l,$f];
}

my $prev="0";
my $label="lbl000";
sub savelabel {
	my ($f,$l)=@_;
	if ($f eq "fake") {
		$label=$l;
	} elsif ($f eq "prev") {
		$prev=$l;
	} else {
		die "unknown label";
	}
}

my $state=0;
my $immediate=0;

sub def {
	my ($w)=@_;
	if ($state == 0) {
		if ($w eq 'def{') {
			$state=1;
			return 1;
		}
		if ($w eq 'imm{') {
			$state=1;
			$immediate=1;
			return 1;
		}
		return 0;
	}
	if ($state == 1) {
		$l=$label++;
		print $mh "def $w $l\n"; # create mapping in "dictionary"
		my $ew=$w;
		$ew=~s/\"/\\\"/g;
		print qq([ "def", "$ew", "$l", $immediate, [ );
		$defs->{$w}=$l;	# for setting up a local mapping
		$state=2;
		return 1;
	}
	if ($state == 2) {
		if ($w eq '}def') {
			print ']],', "\n";
			$state=0;
			return 1;
		}
		if ($w eq '}imm') {
			print ']],', "\n";
			$state=0;
			$immediate=0;
			return 1;
		}
		return 0;
	}
	die "received $w in state $state";
}

my $handle={
	'code'	=> \&code,
	'var'	=> \&var,
	'def'	=> \&olddef,
	'label'	=> \&savelabel,
};
my @l;
my @args=@ARGV;	# all the args are assumed to have name to label mappings
for my $a (@args) {
	@ARGV=($a);               # read each of the args passed in as a file
	while(<>) {               # reading one line at a time
		($t,$f,@l)=split;     # split'ing the line into type, name and label
		$handle->{$t}($f,@l); # and handle each type separately
	}
}

print '[';
while (<>) {
	s/^\[$// && next;		# standalone picture comment: [
	s/^\[\s+.*$// && next;	# starting comment: [ 1 2 3
	s/\s+\[$//;				# embedded picture comment: foo [
	s/\s+\[\s+.*$//;		# trailing comment: foo [ 1 2 3
	for my $w (split) {
		next if def($w);
		if ($w eq 'loop{') { print '[ "loop", [', "\n"; next}           #loop{
		if ($w eq '}while{') { print '],1,[', "\n"; next}               #}while{
		if ($w eq '}until{') { print '],0,[', "\n"; next}               #}until{
		if ($w eq '}loop') { print ']],', "\n"; next}                   #}loop
		if ($w eq 'if{') { print '[ "cond", [ ', "\n"; next}            #if{
		if ($w eq '}else{') { print "\n",'],[', "\n"; next}             #}else{
		if ($w eq '}if') { print ']],',"\n"; next}                      #}if
		if ($w =~ /^\'(.)\'$/) { print "[ 'lit', ord('$1')],\n"; next}  #chr
		if ($w =~ /^(-?\d+)$/) { print "[ 'lit', int($1)],\n"; next}    #int
		if ($w =~ /^\#(-?\d+)$/) { print "[ 'skip', int($1)],\n"; next} #skip
		if ($w =~ /^(-?0x[\dA-Fa-f]+)$/){print "['lit',oct('$1')],\n";next} #hex
		if ($l = $map->{$w}) { print "['prim','$l','$w'],\n"; next}  # primitive
		if ($l = $varmap->{$w}) { print "['lit','$l'],\n"; next}      # variable
		if ($l = $defs->{$w}) {
			if (ref $l eq 'ARRAY') {
				print "['visit','$l->[1]','$w'],\n"
			} else {
				print "['visit','$l','$w'],\n"
			}
			next;
		}
		print "[ 'word', '$w'],\n";                            # everything else
	}
}
print '];';
print $mh "label fake $label\n";
if ($gendict) {
	print $mh "label prev $prev\n";
}
close $mh;

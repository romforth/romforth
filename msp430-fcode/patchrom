#!/usr/bin/perl -w

# patchrom : run a second pass to patch any forward/backward labels
#
# Copyright (c) 2023-2024 Charles Suresh <romforth@proton.me>
# SPDX-License-Identifier: AGPL-3.0-only
# Please see the LICENSE file for the Affero GPL 3.0 license details

# This is just a minimally modified version of the C/patchrom script.

# Assemblers can do math and resolve forward/backward references to labels used
# for offset calculations inside array definitions so that a "computed entry"
# such as ".word foo-.-2" can be evaluated during assembly time. The C compiler
# does not have an obvious way to resolve such "computed elements" within a
# statically defined array. This script is a workaround to patch up such code.
#
# The overall design is that genrom is used to generate the array elements
# just as it does for assembly code and then, just for C code, in a second pass
# we use this "patchrom" script to resolve just those "computed offsets".
#
# Note that since rom.h was generated by genrom, we can assume it adheres to a
# fairly strict format. The following assumptions are made about the format :
#	1. Comments start with // upto the end of line and are ignored
#		- this is needed to ignore extraneous matches within comments
#	2. Labels begin at the start of line and are delimited by a colon(:)
#	3. Locations to be patched start with a tab followed by PATCH and name
#	4. Each element in the rom array is delimited by a comma(,)

use strict;
my ($v,$vv,$expr);
my $dot=0;	# this is the equivalent of the '.' in assembler code
my $label={};	# to store label -> dot location mapping
my $want={};	# to store the list of wanted forward reference labels
my $agg=[];	# the output is stored in an array so it can be patched anytime
while(<>) {
	s/\s+\/\/.*//;		# ignore // comments upto the end of the line
	if (/^(\S+)\:/) {	# if this is a label, starting a line then:
		$label->{$1}=$dot;	# save the dot location for future use
		$v=\$want->{$1};	# see if this label is wanted elsewhere
		if ($vv=$$v) {		# and if so,
			for my $i (@$vv) {	# for each saved location
				my ($l,$d)=@$i; # get patch location, distance
				die unless ($agg->[$l]==-1);	# sanity check
				# and then patch it up
				$agg->[$l]="\t.byte ". ($dot-$d) ."\n";
			}
		}
		push @$agg, $_;	# unlike C, assembly code needs all the labels
		next;		# labels don't move the dot location: no $dot++
	}
	if (/^\tPATCH\s+(\S+)$/) {	# if this is a patch location
		$dot++;			# patch locations use a 1 byte offset
		$v=\$label->{$1};	# see if this label was seen already
		if ($vv=$$v) {		# and if so,
			push @$agg, $vv-$dot . ",\n";	# patch a backward jump
		} else {		# otherwise, if it is a new label
			$v=\$want->{$1};	# see if it was wanted already
			unless ($vv=$$v) {	# if not
				$vv=$$v=[];	# add it initialized to empty
			}
			push @$vv, [0+@$agg, $dot];	# add the new request
			push @$agg, -1;		# initialize the patch location
		}
		next;
	}
	push @$agg, $_;		# for everything else
	s/\,\s+$//;		# account for each element by
	$dot+=split(/\,/);	# splitting on all of the commas on each line
}
print join('', @$agg);		# print it all out after all patches are done
